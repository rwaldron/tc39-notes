<!doctype html>
<meta charset="utf-8">
<link rel="apple-touch-icon" sizes="180x180" href="img/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="img/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="img/favicon-16x16.png">
<link rel="manifest" href="img/site.webmanifest">
<link rel="mask-icon" href="img/safari-pinned-tab.svg" color="#5bbad5">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.6.0/github-markdown.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/javascript.min.js"></script>
<title>December 1, 2016 Meeting Notes</title>
<body class="markdown-body">
<a href="javascript:history.back()">Back</a>
<a href="#december-1-2016-meeting-notes"><h1 id="december-1-2016-meeting-notes">December 1, 2016 Meeting Notes</h1></a><hr>
<p>Allen Wirfs-Brock (AWB), Waldemar Horwat (WH), Jordan Harband (JHD), Thomas Wood (TW), Brian Terlson (BT), Michael Ficarra (MF), Adam Klein (AK), Jeff Morrison (JM), Chip Morningstar (CM), Dave Herman (DH), Yehuda Katz (YK), Leo Balter (LB), Sebastian Markbåge (SM), Kent C. Dodds (KCD), Kevin Gibbons (KG), Tim Disney (TD), Peter Jensen (PJ), Juan Dopazo (JDO), Domenic Denicola (DD), Daniel Ehrenberg (DE), Shu-yu Guo (SYG), JF Bastien (JFB), Keith Miller (KM), Michael Saboff (MS), Chris Hyle (CHE), Alex Russell (AR), Brendan Eich (BE), Caridy Patiño (CP), Diego Ferreiro Val (DFV), James Kyle (JK), Eric Ferraiuolo (EF), Mathias Bynens (MB), István Sebestyén (IS), Mark S. Miller (MM), Cristian Mattarei (CMI), Brad Nelson (BNN), Jafar Husain (JH)</p>
<hr>
<a href="#4-approval-minutes-from-last-meeting"><h2 id="4-approval-minutes-from-last-meeting">4 Approval minutes from last meeting</h2></a><p>AWB: Approval of previous meeting minutes?</p>
<p>IS has distributed the minutes via TC39 Email Reflector and has also uploaded it on GitHub.</p>
<a href="#conclusionresolution-4-approval-minutes-from-last-meeting"><h4 id="conclusionresolution-4-approval-minutes-from-last-meeting">Conclusion/Resolution</h4></a><ul>
<li>Approved</li>
</ul>
<a href="#6i-determine-2017-tc39-meeting-dates-locations-and-hosts"><h2 id="6i-determine-2017-tc39-meeting-dates-locations-and-hosts">6.i Determine 2017 TC39 meeting dates, locations, and hosts.</h2></a><p>IS: WE said that in 2017 there will be no European meeting. But if nothing else works Ecma and Switzerland are always a fall-back possibility for organization of TC39 meetings. Of course we need a few months lead-up time.
I will also bring up the issue of the TC39 at the GA next week. Maybe I can find some additional hosting help in the Bay Area. Last point (not said in the meeting): we may try to access some of our university members, Universities usually easily have sufficient large rooms, especially if we come during a time when there is no teaching.</p>
<p>AWB: January meeting at Salesforce.</p>
<p>DG: Yes</p>
<p>AWB: March, May, November still open.</p>
<p>DD: Looking into May in New York</p>
<p>IS: We could also have it in Europe, in Switzerland</p>
<p>AWB: We prevously decided not to have a Europe meeting, but we'll have two east-coast meetings. We should find the meeting place for March ahead of time</p>
<p>SYG: Moz can host, but don't have the space necessary for the size of this group now</p>
<p>AWB: Last meeting 40+</p>
<p>JHD: I'm looking into hosting, tentatively for November.</p>
<p>AWB: What about Google New York in March rather than May?</p>
<p>DD: Maybe</p>
<p>KCD: PayPal can host in March, tentatively. My manager supports it.</p>
<p>AWB: PayPal has hosted in the past.</p>
<a href="#conclusionresolution-6i-determine-2017-tc39-meeting-dates-locations-and-hosts"><h4 id="conclusionresolution-6i-determine-2017-tc39-meeting-dates-locations-and-hosts">Conclusion/Resolution</h4></a><ul>
<li>January: Salesforce San Francisco, Jan 24-26</li>
<li>March:  Paypal  San Jose, March 21-23</li>
<li>May: Google New York, May 23-25</li>
<li>July: Microsoft Redmond, July 25-27</li>
<li>September: Bocoup Boston, Sept 26-28</li>
<li>November: AirBnB Bay Area, Nov 28-30 (tentative)</li>
</ul>
<a href="#12iic-promiseprototypefinally"><h2 id="12iic-promiseprototypefinally">12.ii.c Promise.prototype.finally</h2></a><p>(Jordan Harband)</p>
<p>JHD: Looking at the spec, .catch() calls out to .then(), and .finally() should do the same thing. This removes the concern that I raised about how we should do this wrapping check--we'll just follow what .then() does.</p>
<p>Details in PR: <a href="https://github.com/tc39/proposal-promise-finally/pull/14#issue-192162240">https://github.com/tc39/proposal-promise-finally/pull/14#issue-192162240</a></p>
<p>Downside of finally calling into .then:</p>
<ul>
<li>another call added</li>
<li>another place where spec created functions are exposed to user code.</li>
</ul>
<p>AWB: Implementations can do lots of things to make the overhead of closures go away.</p>
<p>DE: Actually, it's hard to eliminate the allocations totally, in some cases, if it is bound to a particular thing.</p>
<p>AK: And we are seeing this with Promises; we are doing a lot of work to optimize, but we are still having a fight with Bluebird as they don't care about following the expensive parts of the spec.</p>
<p>JHD: Even if Promises call into methods, most parts of the spec call directly into internal algorithms.</p>
<p>AWB: We shouldn't permanently introduce inconsistencies because we are having trouble dealing with coming up with optimizations in the short term.</p>
<p>DD: We could further remove the way Promises call into internal methods, e.g., for catch. Maybe that would be web-compatible, even if it's a technically breaking change.</p>
<p>JHD: Seems like this comes down to, do we prefer the observability or the consistency?</p>
<p>MM: I prefer consistency. finally and catch should be consistent with each other.</p>
<p>AWB: This changes the requirements for subclasses, so they have to implement three methods instead of one.</p>
<p>YK: Let's come back at a future meeting to go for Stage 3. then doesn't seem like a good kernel method.</p>
<p>AWB: I'd want to understand the benchmarks better; is this all microbenchmarks?</p>
<p>BT: ecmarkup improved build times by 25% by using Bluebird rather than V8 native promises.</p>
<p>YK: The gap is partly spec compliance and partly implementation quality. Ember does get faster</p>
<p>MM: What are the use cases for Promise subclassing?</p>
<p>JHD: Probably not much usage on the web at the moment.</p>
<p>DD: Because we have the duck type chaining assimilation system, we don't need subclassing.</p>
<p>MM: Would it be web-compatible to kill Promise subclassing?</p>
<p>AWB: What, are we going to introduce final classes?</p>
<p>DD: Just not call into the kernel methods, just call the internal algorithm. It would be more like map, rather than based on kernel methods.</p>
<p>YK: Maybe we should make a protocol for await, to override behavior, rather than the thenable assimilation protocol. I'll come up with a more concrete proposal in the future.</p>
<p>AWB: You can pursue a brand checking mechanism as well, and this may lend itself to advanced JIT optimizations</p>
<a href="#conclusionresolution-12iic-promiseprototypefinally"><h4 id="conclusionresolution-12iic-promiseprototypefinally">Conclusion/Resolution</h4></a><ul>
<li>Remain at Stage 2</li>
<li>Solicit reviews from both spec text versions by January</li>
</ul>
<a href="#12iie-variation-on-unambiguousjavascriptgrammar"><h2 id="12iie-variation-on-unambiguousjavascriptgrammar">12.ii.e Variation on UnambiguousJavaScriptGrammar</h2></a><p>(Dave Herman)</p>
<p>DH: Goal is to get to Stage 1 and discuss further with Node, whose represenatives weren't able to make it today.</p>
<p>AK: Thanks for articulating your goal clearly at the beginning!</p>
<p>DH: Script or module?</p>
<p>AWB: This isn't a new question. We had the same discrimination dilemma before between scripts and CommonJS scripts, which are actually function bodies.</p>
<p>DH: The goal is to allow your module source file to always be interpreted as a module; this is useful on the web as well.</p>
<p>WH: You can trivially do that today without needing any proposal. How is this a motivation?</p>
<p>DH: Node's proposal: Let's mandate that you have at least one import or export statement in the module grammar. Then, zero overlap, so tools can disambiguate.</p>
<p>AWB: A problem with that proposal is chapter 16. An implementation is allowed to extend semantics that would make import or export statements parse in scripts.</p>
<p>DH: Node's proposal: If there's out-of-band data indicating whether it's a script or a module, then early error for presence/absense mismatch. If there is no out-of-band data, then decide based on presence.</p>
<p>DH: This violates some important constraints.</p>
<p>WH: When deciding based on presence, you can completely change of meaning of an entire file at the end of the file.</p>
<p>DH: Also <code>export {}</code> is a weird magic incantation.</p>
<p>DH: Don't want to mandate a bogus export even if living in a world in which there are only modules.</p>
<p>DH: Alternate proposal: <code>&quot;use module&quot;</code> at the beginning of the file. Don't mandate it, but that's a way to switch into module mode. Not required for <code>&lt;script type=&quot;module&quot;&gt;</code>.</p>
<p>WH: (in regards to using the presence of an import statement to distinguish scripts from modules) A script can never import a module?</p>
<p>DH: That's true now. That might not be true in the future.</p>
<p>(Discussion about import statements in scripts: If we allowed that, then the Node proposal would break.)</p>
<p>DH: I don't want to force either <code>export {}</code> or <code>&quot;use module&quot;</code> in an all-module ecosystem where it is indicated out-of-band. Also, refactoring-wise, bad if removing an import changed semantics significantly.</p>
<p>DH: So, the proposal is instead, &quot;use module&quot;, optional to force into that mode, basically the same as <code>export {}</code> would've been.</p>
<p>WH: Is this your proposal or Node's proposal?</p>
<p>DH: This is my variation to their proposal.</p>
<p>AWB: Why not have this happen on Node's part, now? Couldn't Node look for explicit imports or exports, and tell developers this, and implement &quot;use module&quot;?</p>
<p>DH: That's saying something about the meaning of content in JavaScript which deserves standardization.</p>
<p>DD: If it only means something in one embedding environment, then it can be done at their level.</p>
<p>JM: Maybe this should work across environments.</p>
<p>AK: Yes, that's why we need to discuss here, if it should work on the web too.</p>
<p>DH: So, the proposal is to allow the &quot;use module&quot; in addition to the import/export conditionality. &quot;use module&quot; would be an early error in a script on the web, permitted but not required in modules on the web, and in Node
it would be the conditionality. I wouldn't want &quot;use module&quot; to have to be sprinkled all over the top of all modules, though.</p>
<p>WH: This suffers from the same perils as you just listed as arguments against Node's proposal. If you use the presence of import statements, scripts will be misclassified as modules in the future when we add the ability to import into scripts. To make this work you'd need to either get rid of the import/export statement sniffing or define a &quot;use script&quot; in addition to &quot;use module&quot; to in-band force scripts to be interpreted as scripts.</p>
<p>AK/CP: What if we just did <code>&quot;use module&quot;</code> without the import/export conditionality?</p>
<p>DH: (Experimental implementation at <a href="https://github.com/dherman/esprit">https://github.com/dherman/esprit</a>)</p>
<p>DH: Usually the mode is known upfront, but the deferred check will have some cost in the cases where it runs. Maybe the import/export conditionality will only come up in a few of the Node corner cases.</p>
<p>AK: So you think it's uncommon is because Node folks were receptive to the idea that it could only come up in certain circumstances? (NB: Background is that the import/export check may require parsing multiple times.)</p>
<p>DH: We should aim for out-of-band signalling most of the time, and in-band only for a couple remaining edge cases, and for defensive programming.</p>
<p>DD: The node leadership is already happy with .mjs</p>
<p>AWB: From Node, this isn't a problem between discriminating between modules and scripts, but modules and CommonJS modules. This is Node's problem: Node doesn't handle Scripts, only CommonJS modules. So, given a source file, Node needs to determine if this should be processed as ES or CJS, it can do its heuristics. Differences in semantics? Mostly strict mode. Does that matter much?</p>
<p>KG: Annex B 3.3 being excluded is big</p>
<p>MM: Strict arguments are very different</p>
<p>AWB: I think anything that Node might be confused if they take a script-like module and treat it as a CJS module.</p>
<p>YK: They don't think that's true empirically.</p>
<p>JM: We are far over timebox, let's move to another agenda item.</p>
<p>WH: I object to Stage 1. It would be a waste of the committee's time as it is strictly worse than the previous proposal, and it suffers from the same issues as the Node detection solution, and it doesn't solve the problem of import statements in scripts in the future.</p>
<p>DH: It would be great if this could reach Stage 1, as this relates to JDD&amp;Bradley's proposal.</p>
<p>WH: We have to wait to see that proposal</p>
<p>AWB: One of the criteria for Stage 1 is that we think it's worth spending time</p>
<p>AK: Actually it says we &quot;expect&quot; to spend time on it. I would expect to spend time on it!</p>
<p>BT: This is a feature request from an important user of JavaScript and we shouldn't just dismiss it.</p>
<a href="#conclusionresolution-12iie-variation-on-unambiguousjavascriptgrammar"><h4 id="conclusionresolution-12iie-variation-on-unambiguousjavascriptgrammar">Conclusion/Resolution</h4></a><ul>
<li>Stage 1 acceptance</li>
<li>The committee has deep doubts about this proposal</li>
</ul>
<a href="#14ii-import-open-issues-and-stage-3-discussion"><h2 id="14ii-import-open-issues-and-stage-3-discussion">14.ii import() open issues and stage 3 discussion</h2></a><p>DD: For Node, JHD reached out to Bradley Farias of Node and confirmed that we can start the import of the module asynchronously, as he had suspected. Therefore, the hook can be clarified to always be asynchronous, not synchronous or asynchronous as previously.</p>
<p>DD: For MM's membrane penetration concern, the plan is that we will be working towards hooking of agent hooks (&quot;the loader spec&quot;), though we aren't blocking on it. Current embedding environments do support hooking.</p>
<p>DD: (walking through <a href="https://github.com/tc39/proposal-dynamic-import/issues/26">https://github.com/tc39/proposal-dynamic-import/issues/26</a>)</p>
<p>MM: We're expecting that we'll work towards a standardized loader spec for generalized hooking, and be happy with how embedding environments (e.g., Web and Node) do provide an API.</p>
<p>AWB: If need API, then say you need in spec.</p>
<p>MM: minimal requirement, have a standardized API now. Minimal requirement that there exists a way for this to be implemented on all runtimes, there must be a spec hook to</p>
<p>AWB: We can also require host environments to provide a way to expose these hooks, rather than just expect it, writing out in the spec what is required for it to be sufficient.</p>
<p>DD: This is novel, and I'd rather not tie my proposal to that. But it seems like a possible path. I'm expecting to get a PR from Mark to formalize whatever is required.</p>
<p>MM: I'd like to look at what hosts expose more closely. Is there great urgency?</p>
<p>DD: We'd like to implement this.</p>
<p>AWB: And you won'd do it if it's not Stage 3?</p>
<p>DD: Right</p>
<p>AWB: Stage 3 is about getting usage and implementation feedback, and adjusting if necessary. We are anticipating feedback from Mark</p>
<p>MM: In this delecate agreement, I'd like to take a look at some details before giving a final signoff.</p>
<p>AWB: But we're not talking about changing the normal public surface area of the feature. So there's no particular reason why it should block Stage 3.</p>
<p>MM: I am not expecting it to block Stage 3, but I'd like more time to look at it. But I can do that at Stage 3.</p>
<p>DD: Final obstacle was run-to-completion semantics, from AWB. Talking with BT, we were thinking of working this out spec mechanics during Stage 3. I have a note indicating the need for run-to-completion.</p>
<p>AWB: Should be a normative requirement!</p>
<p>DD: Done.</p>
<p>WH: Any remaining syntax issues from Tuesday? For the record, what was the decision?</p>
<p>DD: Result is that it looks like a function call.</p>
<p>AK: With some static restrictions.</p>
<p>DE: Stage 3 is good because it indicates some stability that helps implementations know they're not wasting their effort.</p>
<p>MM: Will this ship before the next meeting, prohibiting future changes?</p>
<p>AK: We'll initially develop it behind a flag, and it will go through normal Chrome shipping processes, which take some time.</p>
<a href="#conclusionresolution-14ii-import-open-issues-and-stage-3-discussion"><h4 id="conclusionresolution-14ii-import-open-issues-and-stage-3-discussion">Conclusion/Resolution</h4></a><ul>
<li>Stage 3 acceptance</li>
</ul>
<a href="#13iib-private-state"><h2 id="13iib-private-state">13.ii.b Private State</h2></a><p>(Daniel Ehrenberg)</p>
<ul>
<li><a href="https://github.com/tc39/proposal-private-fields">proposal</a></li>
<li><a href="https://docs.google.com/presentation/d/1QBK8GsTYmQHJQJm_P0HuELNN4uGkm9gB7Df9g4tRK-o/edit#slide=id.g1994dec4f4_0_35">slides</a></li>
</ul>
<p>DE: Private state to stage 2</p>
<ul>
<li>Syntax is same</li>
<li>Follows Kevin Smith's proposal</li>
<li>Class private state, not instance private</li>
</ul>
<pre><code class="language-js">class Foo {
    #x;
    #y = z;
    foo() { 
        #x++; 
        return this.#x;
    }
}
</code></pre>
<p>DE: Questions remain for both private state and public fields, but public fields still at stage 2</p>
<p>AWB/WH: They're in fact the same questions. Apply to both.</p>
<p>DE: (semantics)</p>
<ul>
<li>Only accessible from methods inside class body (&quot;hard-private&quot;)</li>
<li>Internal slots mapping objects to field values</li>
<li>Add field after <code>super()</code> returns, or at beginning in base class</li>
<li>Intersperse initializer evaluation with field addition</li>
<li>Throw on redundant property definition</li>
<li>Scope of initializers as in property declarations</li>
</ul>
<p>The intention is to match public fields, need to be interleaved, specifically the ordering of steps e.g. adding fields.</p>
<p>AWB: Concerns about separate proposal for public fields. Merge the proposals.</p>
<a href="#de-the-plan-is-to-merge-the-specs-for-stage-3"><h2 id="de-the-plan-is-to-merge-the-specs-for-stage-3">DE: The plan is to merge the specs for Stage 3</h2></a><p>DE: If feedback reveals that the # syntax for private state is fatally unworkable, we wouldn't want to kill public state because of it</p>
<p>MM: if integration reveals issues for one and not the other? THen we can address?</p>
<p>AWB: Or drop entirely?</p>
<p>YK/AWB/DE: (discussion of the merging concerns, but only w/ regard to Stage 3?)</p>
<p>AWB: Concerns about separate proposals modifying the same spec algorithms. They need to be merged when we get to that level of detail.</p>
<ul>
<li>in stage 2, merge must be addressed</li>
</ul>
<p>DH: I love the smell of consensus in the afternoon ;)</p>
<p>DE: Should there be a way, through reflection, to access private state outside of the class? No.</p>
<ul>
<li>Previously, formalism based on weakmaps</li>
<li>New formalism is same, but without the GC semantics</li>
</ul>
<p>DE: Add field after <code>super()</code> returns, or at beginning in base class—no matter where <code>super()</code> is called</p>
<p>AWB: May be issue? Reflect.construct call is intended to be an alternative <code>super()</code>. Possible to move this in the construct, doesn't have to relate to token</p>
<ul>
<li>construct is where belongs</li>
</ul>
<p>WH: Concerns that one shouldn't be able to use this to stick a class's private fields onto arbitrary unrelated objects</p>
<p>...</p>
<p>DE:</p>
<p>Interaction with other features</p>
<ul>
<li>Decorators -- reify a PrivateFieldIdentifier() object (<a href="https://github.com/tc39/proposal-private-fields/blob/master/DECORATORS.md">https://github.com/tc39/proposal-private-fields/blob/master/DECORATORS.md</a> )</li>
<li>A decorator can provide soft-private state</li>
<li>Private methods -- a clean extension with the syntax you expect (<a href="https://github.com/tc39/proposal-private-fields/blob/master/METHODS.md">https://github.com/tc39/proposal-private-fields/blob/master/METHODS.md</a> )</li>
<li>Static private -- ditto (<a href="https://github.com/tc39/proposal-private-fields/blob/master/STATIC.md">https://github.com/tc39/proposal-private-fields/blob/master/STATIC.md</a> )</li>
<li>Friends -- may be lexically exposed via static block (<a href="https://github.com/littledan/proposal-class-static-block">https://github.com/littledan/proposal-class-static-block</a> )</li>
</ul>
<pre><code class="language-js">let barGetter;
class Foo {
  #bar;
  static { barGetter = instance =&gt; instance.#bar }
}
</code></pre>
<p>MM: could via decorator, declare a private field to be effectively const, initialized, not further modifiable?</p>
<p>DE: Not presently</p>
<p>YK: Not yet</p>
<p>(back to syntax)</p>
<p>MM/DE: (discussion about the dot in <code>o.#p</code>, ultimately they came around to the dot.)</p>
<p>DE: Why hard private? (<a href="https://docs.google.com/presentation/d/1QBK8GsTYmQHJQJm_P0HuELNN4uGkm9gB7Df9g4tRK-o/edit#slide=id.g1994dec4f4_0_20">https://docs.google.com/presentation/d/1QBK8GsTYmQHJQJm_P0HuELNN4uGkm9gB7Df9g4tRK-o/edit#slide=id.g1994dec4f4_0_20</a> )</p>
<p>WH: This relies on not being able to create fake instances of the class that has the private property. That's the concern I raised earlier.</p>
<p>AWB/WH: We need to explore that.</p>
<p>DH: possibly making a mistake by using the concise syntax for the air-tight private state?</p>
<ul>
<li>The question is: what do people want in the real world? Afraid we're missing that</li>
</ul>
<p>JM: Have you seen the decorator opt-out?</p>
<p>DH: yes, but concerned we're making wrong decision.</p>
<p>DE: the developer field is split evenly, some for hard and some for soft private.</p>
<p>JM: The concern of hard private is that its very hard to debug</p>
<ul>
<li>if debugging in a debugger, you can see the hard private, but your tests cannot</li>
</ul>
<p>WH: Same argument could be made about the other hard private facility of the language, namely locals in functions. Although some might want non-air-tight functions (for example for testing), it's not worth it to add another kind of functions to the language. Just like with private fields, a debugger will show you the values of locals in functions.</p>
<p>YK: Some know how to use underscore (prefix), some symbols; might use underscore as example that we did it wrong</p>
<p>(Discussion about all the problems of using underscore, ie. not soft-private/soft-protected)</p>
<p>MM: It's important for me that hard-private be ergonomic.</p>
<p>AWB: The key elements of the proposal are hard private and lexical scoping of private declarations. If either of those were reversed, this would turn into a radically different proposal. If we're advancing this to stage 2, it's with the understanding that these will be in the proposal.</p>
<p>DE/DH: (further discussion of hard private).</p>
<ul>
<li>Want real usability feedback</li>
</ul>
<p>YK: (point about developer ergonomics compared to similar cases re: decorators)</p>
<p>AWB: Proxy issue?</p>
<p>DE: Resolution was: can add private state to proxy</p>
<p>MM: WEakMap semantics: proxy has identity and can key on proxy</p>
<p>MM, WH: No proxy issue.</p>
<p>MM: Intended to be observationally equivalent to weak maps. If there is a place that isn't, it's a bug.</p>
<p>DE: Can add text that explains the equivalence to weakmaps; semantics of this proposal, etc.</p>
<p>Internal slot-based specification mechanics</p>
<ul>
<li>Private State Identifier specification type</li>
<li>[[PrivateStateValues]] is a List with pairs mapping Private State Identifiers to their values</li>
<li>Difference from WeakMaps unobservable except for implied GC semantics</li>
</ul>
<p>DE: Q. is this just too unergonomic? Some wanted @, not #—and very opposed to #. Some Wanted <code>private</code>.</p>
<p>WH: Need a sigil or equivalent. We've spent years working through attempts to define private state without any distinguishing sigils on use. None of them worked. They work fine in statically typed languages, but in dynamically typed ECMAScript were hopelessly mired in the same class of namespace shadowing problems that plagued the with statement. Consider what happens if a class defines a private field called &quot;length&quot; and also wants to access a length field of an unrelated object.</p>
<p>AWB: 6-7 years ago worked through extensive ways of doing this and all had problems.</p>
<p>AWB: Extensively documented in old wiki</p>
<p>DE: static private, methods included? Or wait?</p>
<p>AWB: Do the full package here.</p>
<p>KG: why? (as opposed to a later proposal, if confident that this will allow for a later proposal?)</p>
<p>AWB: cross cutting concerns, if not pinned down together, and proceed with only confidence, then discovery later will be problematic or impossible to fix.</p>
<p>DE: Open issue: require a &quot;private&quot; keyword on declarations? (i.e. <code>private #x;</code> instead of <code>#x;</code>)</p>
<p>DE: Pro: useful for learning the language</p>
<p>WH: Any syntactic reason for needing a keyword?</p>
<p>DE: No.</p>
<p>AWB: had to chose: follow separator of block or object literal, went <code>;</code></p>
<p>YK: important to support commas to enumerate a list of fields:</p>
<pre><code class="language-js">class A {
  #x, #y, #z    
}
</code></pre>
<p>Annoying to write:</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{
  private x;
  private y;
  private z;  
}
</code></pre>
<p>Bad: private and decorators and no comma list</p>
<p>WH: Whether or not we allow commas is orthogonal to this proposal.</p>
<p>DE: could make private keyword optional, but is weirder</p>
<p>YK: <code>private @protected foo</code> is something to keep in mind?</p>
<p>DD: Does anyone like the <code>private</code> keyword?</p>
<p>AWB: the sigil alone is hard to read, <code>public</code> and <code>private</code> are clear</p>
<p>WH: Can't mandate <code>public</code> and <code>private</code> keywords. Public methods don't use a keyword, so that ship has sailed assuming that we'll want private methods at some point. My preference is no keywords — sigil only.</p>
<p>KG: opposed to <code>private</code>, but those who are opposed to <code>#</code> are less opposed to <code>private #x</code>.</p>
<p>(discussion re: <code>=</code> or <code>:</code>)</p>
<p>CM: why is this even a question?</p>
<p>JM: There is a question on public fields, <code>=</code> is assign/set, <code>:</code> is define—still not sure which will be correct?</p>
<p>KG: only relevant for public fields, evaluation order</p>
<p>YK: TypeScript and Babel transpile as:</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{
  x = <span class="hljs-number">1</span>;  
}
</code></pre>
<p>to</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> A = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>{
  _classCallCheck(<span class="hljs-keyword">this</span>, A);

  <span class="hljs-keyword">this</span>.x = <span class="hljs-number">1</span>;
};
</code></pre>
<p>JK: It does this by default, however when you enable &quot;spec&quot; mode it will switch to using a defineProp to set configurable to false</p>
<p>KG: concern that if not addressed now, Babel will proceed and like the &quot;sigil swap&quot;, it will become hard to change later.</p>
<p>AK: valid concern, but <code>public</code> is much more widely used</p>
<p>DE: much more open to <code>private</code> with comma list</p>
<p>JK: This is a slightly different situation from the sigil swap, there is a better migration path available</p>
<p>WH: keyword ship has sailed, problems when we do private methods with <code>private</code> but public without <code>public</code></p>
<p>AWB: This is why I proposed <code>own</code> and not</p>
<p>AWB: Change to IdentifierName, not IdentifierPart</p>
<p>WH: Yes, I raised that the last time we discussed this proposal.</p>
<p>JM: Why?</p>
<p>AWB: Don't want properties called #1, #2, #3</p>
<p>JM: Why?</p>
<p>AWB: We use IdentifierName in the grammar</p>
<p>WH: It seems odd to have a PrivateName be a single token. The more natural way to express it would be as two tokens, <code>#</code> followed by an IdentifierName.</p>
<p>KG: Won't that allow whitespace between <code>#</code> and IdentifierName?</p>
<ul>
<li>The hash is intended to be thought of as part of the property name, ie:</li>
</ul>
<pre><code class="language-js">this.
  #foo.
  #bar;
</code></pre>
<p>(RW, LB: Weird)</p>
<p>AWB: No whitespace between <code>#</code> and <code>foo</code> in <code>#foo</code>, but also <code>foo</code> not IdentifierPart</p>
<p>WH: Want whitespace allowable on either side of #</p>
<p>DE: Should private state be accessible within eval?</p>
<a href="#conclusionresolution-de-the-plan-is-to-merge-the-specs-for-stage-3"><h4 id="conclusionresolution-de-the-plan-is-to-merge-the-specs-for-stage-3">Conclusion/Resolution</h4></a><ul>
<li>Stage 2 acceptance</li>
<li>hard private, lexical scoping</li>
</ul>
<a href="#13vi-process-proposal-require-an-implementation-to-land-a-normative-pr-to-the-spec"><h2 id="13vi-process-proposal-require-an-implementation-to-land-a-normative-pr-to-the-spec">13.vi Process proposal: require an implementation to land a normative PR to the spec</h2></a><p>(Daniel Ehrenberg)</p>
<ul>
<li><a href="https://gist.github.com/littledan/f85d2d1f4cff44927a75afd5d30bbe2e">proposal</a></li>
</ul>
<p>WH: What are the majority of the spec pull requests?</p>
<p>BT: Editorial. Among the remainder, the majority are consensus items.</p>
<p>DE: proposes that PRs for normative changes should also have an implementation before being merged.</p>
<p>AWB: case by case?</p>
<p>MM: We can adopt this process and apply it on a case-by-case basis</p>
<p>AWB: what if it's a bug?</p>
<p>DE: Want a high bar to making normative changes to the spec to avoid bugs.</p>
<p>WH: It also makes a high bar to fixing bugs.</p>
<p>AWB: Caution against adding too much burden to the process.</p>
<p>BT: Don't want to inject a lot of process into simple things. Don't think adopting this proposal would change anything in practice.</p>
<p>YK: But it would cause more process lawyering.</p>
<a href="#conclusionresolution-13vi-process-proposal-require-an-implementation-to-land-a-normative-pr-to-the-spec"><h4 id="conclusionresolution-13vi-process-proposal-require-an-implementation-to-land-a-normative-pr-to-the-spec">Conclusion/Resolution</h4></a><ul>
<li>Raised the issue, pay attention.</li>
</ul>
<a href="#13vii-open-ended-how-can-we-promote-diversity-and-inclusion-in-tc39"><h2 id="13vii-open-ended-how-can-we-promote-diversity-and-inclusion-in-tc39">13.vii Open-ended: How can we promote diversity and inclusion in TC39</h2></a><p>(Daniel Ehrenberg and others)</p>
<p>DE: How can we improve this?</p>
<p>AWB: member companies need to send more diverse language implementors</p>
<p>(general discussion wrt adopting a Code of Conduct that applies to diversity based on demographics background)</p>
<p>WH: Code of Conduct and meeting participation changes must be handled at the ECMA General Assembly level. Also, ECMA has a code regulating conduct.</p>
<p>RW: We should talk to István to have ECMA adopting this Code of Conduct</p>
<p>(general agreement)</p>
<p>RW: The next step is we as delegates communicate to our companies that we should sponsor and support diversity, affecting who we bring to the meetings as well. This might be done via scholarship or otherwise.</p>
<p>MM: We lack geographical diversity.</p>
<p>WH: We've never had a meeting in the midwest. In the US we've only had meetings near ocean coasts.</p>
<p>RW: (explanation of counter to geographic claim, w/r to specific demographics and personal safety)</p>
<p>MM: Geographical location is one of the few things that this committee has direct control over</p>
<p>(discussion about different working and debate styles)</p>
<p>WH: The biggest indictment of our committee is what happened to Kevin Smith in Munich.</p>
<p>JK: There are groups unwilling to come, due to the nature of TC39</p>
<p>WH: Are they members?</p>
<p>JK: Certainly within member companies, but also people who don't push their companies to become members       There ertainly within member companies and without</p>
<p>JK: w/r to certain places being unwelcoming to disenfranchised groups. I'd ask that the committee never hold meetings in places where anyone's personal safety isn't guaranteed, eg. countries where gay people are killed for being gay.</p>
<p>DE: Mark makes a good point about geographic diversity; globally, many of our companies are focused on the next billion users, and we don't have much representation from developers who are targeting that, who may have different mental models. It's not just diversity of people who we bring here, but also inclusion of the people that are in the room. Our culture here can be intimidating--it is hard to give a presentation when committee members will interrupt from very early on, and this works for some cultural styles of presenters but not for others.</p>
<p>BT: Sounds like we are all in agreement that diversity is an important issue that we want to work on</p>
<p>MS: It is important for us to work on making this a less intimidating place which is more welcoming to new members.</p>
<p>MM: re: Kevin Smith hostile environment issues:we missed the opportunity to improve ourselves as a group after the incident in Germany</p>
<p>BT: Let's continue this discussion, including developing a statement from the committee that would help companies like mine and Rick's find funding to allow the participation of diverse members.</p>
<p>DFV: It feels like there is unnecessary tension, tension about more than technical things, and it makes me hesitant to speak much. We saw some of that today, where it was uncomfortable to speak. It feels like there is sometimes too much confrontation here.</p>
<p>JK: We can also work to create more resources for people to learn how to get involved.</p>
<p>DE: Maybe we should be fixing our culture to be more respectful and inclusive as the first step; I wouldn't want to bring a lot of new people into a hostile situation. The code of conduct could help here.</p>
<p>SYG: Can we really expect people to follow this?</p>
<p>MS: We are getting better at enforcing timeboxes, but we should consider being even more strict in enforcement--if members don't grant an extension, it should be done.</p>
<p>LB: Some companies may have trouble/refuse participating because they see the lack of diversity and a code of conduct on a company. I have had discouragement from colleagues personally as English is my second language--this made me feel like running away. Fortunately, my employer, Bocoup, on hearing this, put me on the Test262 project and eventually sent me to the committee. I have many people from my country (Brazil) who contact me and want to get in touch about reading the spec, etc. I am just a normal person--I needed to find that, regardless of where I come from, I was able to attend. It would be very useful to have an official document from ECMA saying that ECMA and TC39 commit to social responsibility, where people can feel respected in any sort of background. Everyone should feel encouraged. I am here, I am the proof of it. I feel responsible to bring that forward to the new people.</p>
<a href="#conclusionresolution-13vii-open-ended-how-can-we-promote-diversity-and-inclusion-in-tc39"><h4 id="conclusionresolution-13vii-open-ended-how-can-we-promote-diversity-and-inclusion-in-tc39">Conclusion/Resolution</h4></a><ul>
<li>Consensus that diversity is important and something we'd like to address and improve</li>
<li>Take initial steps to adopt a Code of Conduct and determine how to enforce</li>
<li>Rick Waldron will contact István</li>
<li>Rick to review with Kevin Smith</li>
<li>Representatives should work with their member organizations to promote more diverse representatives, via scholarship/sponsorship or diversification of member team</li>
<li>Extend our charter to include social commitment to committee representative diversity.</li>
</ul>

</body>