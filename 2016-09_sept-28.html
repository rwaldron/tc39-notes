<!doctype html>
<meta charset="utf-8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.6.0/github-markdown.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/javascript.min.js"></script>

<title>September 28, 2016 Meeting Notes</title>
<body class="markdown-body">
<a href="#september-28-2016-meeting-notes"><h1 id="september-28-2016-meeting-notes">September 28, 2016 Meeting Notes</h1></a><hr>
<p>Brian Terlson (BT), Michael Ficarra (MF), Jordan Harband (JHD), Waldemar Horwat (WH), Tim Disney (TD), Michael Saboff (MS), Chip Morningstar (CM), Daniel Ehrenberg (DE), Leo Balter (LBR), Yehuda Katz (YK), Jafar Husain (JH), Domenic Denicola (DD), Rick Waldron (RW), John Buchanan (JB), Kevin Gibbons (KG), Peter Jensen (PJ), Tom Care (TC), Dave Herman (DH), Bradley Farias (BFS), Dean Tribble (DT), Eric Faust (EFT), Jeff Morrison (JM), Sebastian Markbåge (SM), Saam Barati (SBI), Kris Gray (KGY), John-David Dalton (JDD), Daniel Rosenwasser (DRR), Mikeal Rogers (MRS), Jean-Francis Paradis (JFP), Sathya Gunasekasan (SGN), Juan Dopazo (JDO), Bert Belder (BBR), James Snell (JSL), Shu-yu Guo (SYG), Eric Ferraiuolo (EF), Caridy Patiño (CP), Allen Wirfs-Brock (AWB), Brendan Eich (BE), Jacob Groundwater (JGR), Adam Klein (AK)</p>
<hr>
<a href="#es-modules-lifecycle"><h2 id="es-modules-lifecycle">ES Modules Lifecycle</h2></a><p>(Bradley Farias)</p>
<p>Slides: <a href="https://docs.google.com/presentation/d/1aq_QjBUQTovj9aQZQrVzS7l1aiOs3ZNlk7wgNTUEMy0/edit#slide=id.g16ab11d101_51_46">https://docs.google.com/presentation/d/1aq_QjBUQTovj9aQZQrVzS7l1aiOs3ZNlk7wgNTUEMy0/edit#slide=id.g16ab11d101_51_46</a></p>
<p>BFS: We will be talking about host-dependent behavior: The Node module loading hook is specified in a way that meets ES spec requirements. There is a global and local cache &lt;explain details&gt;</p>
<p>(from slide)</p>
<ol>
<li>Resolve (as absolute URL) =&gt; Fetch =&gt; Parse
<ol>
<li>Make Module Record</li>
<li>Place in Global Cache using Absolute URL*</li>
<li>Errors remove records from Global Cache*</li>
</ol></li>
<li>Traversal of import declarations recursively
<ol>
<li>Ensure step 2 has been performed on the dependency</li>
<li>Place dependency in Local Cache using Import Specifier*</li>
<li>Link dependency to module</li>
<li>Errors prevent any evaluation</li>
</ol></li>
<li>Evaluate in post order traversal
<ol>
<li>Errors prevent further evaluation</li>
</ol></li>
</ol>
<p>CP/YK/AWB: (There are items here that are strictly host-specific)</p>
<p>BFS: Necessary for Node</p>
<p>DD: for example the local cache is not required by the spec; we don't have one in browsers</p>
<p>BFS: agreed.</p>
<p>DH: Inherently, dynamic module systems that would want to interact with ESM need a late linking mechanism. Another option would be to delay linking for everything. I would be open to this option. It might not preclude reasonable implementation optimizations.</p>
<p>YK: And modules haven't shipped anyway</p>
<p>AWB: Appears to be an &quot;interpretation&quot; of the requirements, but we need to understand <em>why</em></p>
<ul>
<li>e.g. local caching? Why required?</li>
</ul>
<p>MR: We have caching; we need it</p>
<p>BFS: [~Lifecycle Errors slide]</p>
<pre><code class="language-js"><span class="hljs-comment">// a (entry)</span>
<span class="hljs-keyword">import</span> {fromB} <span class="hljs-keyword">from</span> <span class="hljs-string">'b'</span>;
<span class="hljs-keyword">import</span> {fromC} <span class="hljs-keyword">from</span> <span class="hljs-string">'c'</span>;
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// b</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> fromB = <span class="hljs-string">'b'</span>;
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// c</span>
<span class="hljs-keyword">import</span> {fromB} <span class="hljs-keyword">from</span> <span class="hljs-string">'b'</span>;

<span class="hljs-comment">// FIXME</span>
<span class="hljs-keyword">import</span> {doesntExist} <span class="hljs-keyword">from</span> <span class="hljs-string">'b'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> fromC = <span class="hljs-string">'c'</span>;

<span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>();
</code></pre>
<p>BFS: This causes a link error. no evaluation occurs. B exports to A, C exports to B, and we fail. To implement this in Node, we store things in the global cache, and remove when there are errors resulting.</p>
<p><a href="https://docs.google.com/presentation/d/1aq_QjBUQTovj9aQZQrVzS7l1aiOs3ZNlk7wgNTUEMy0/edit#slide=id.g16ab11d101_51_0">https://docs.google.com/presentation/d/1aq_QjBUQTovj9aQZQrVzS7l1aiOs3ZNlk7wgNTUEMy0/edit#slide=id.g16ab11d101_51_0</a></p>
<p><img src="https://i.gyazo.com/7b287267136248ecc4972cd95a153ce9.png" alt=""></p>
<p>WH: What do you mean by placing b,c into a cache?</p>
<p>BE: It's not a cache; you can't miss. Sounds like the cache would be more accurately be called a table, since you insert things in for a real effect.</p>
<p>AWB: The spec text states when the link error occurs, it all goes away</p>
<p>WH: All of A, B, C disappear?</p>
<p>(confirmed)</p>
<p>DH: I didn't think there was anything in ES2015 about error states, global semantics of the registry</p>
<p>AWB: When you reach an error, it throws, and it unwinds to the old state</p>
<p>DD: Actually, the idempotency requirement is strong. Firefox found a bug in the initial HTML/Modules integration where we violated that requirement, and it caused us to make changes to unwind the state</p>
<p>DH: The slides discuss the idempotency requirements?</p>
<p>(confirmed)</p>
<p>BFS: (remove FIXME)</p>
<p><img src="https://i.gyazo.com/db559bf71469f069698fb765d08b4844.png" alt=""></p>
<p>AWB: The top level was aborted before reaching the end, and result was...?</p>
<p>BFS: One function of the cache is to make sure the module evaluation only occurs for the first time the module was imported, and not again on subsequent imports</p>
<p>BFS: [~Lifecycle parallel loading slide] Diamond imports. We actually plan to evaluate in the order d, b, c, a</p>
<p>AK: Why are the linking and evaluation orders different?</p>
<p>BFS: The linking and initializing bindings steps are logically the same</p>
<p><img src="https://i.gyazo.com/af2eb75c6dff2b72e7946b2eab37a0df.png" alt=""></p>
<p><img src="https://i.gyazo.com/5829601fe73681f7e9dc13a6ed3cbc60.png" alt=""></p>
<p>YK: Spec bug? If hoistable decl and linkage occur in wrong order?</p>
<p>WH: Can anyone produce a concrete example of where this matters?</p>
<p>BFS: This...</p>
<p>(Note: this is far in the future of the deck)</p>
<p><img src="https://i.gyazo.com/a1c0ea7e6590d8844f33a5013c0b05a1.png" alt=""></p>
<p>BFS: [Timing example - hoistable] After linking, functions are available to be called [since functions are hoisted]. If we get some things wrong, foo could be undefined when we try to call it.</p>
<p>AWB: This can't happen.</p>
<p>YK: Is this related to cycles?</p>
<p>BFS: Most of the problems are related to cycles, or things that cross them</p>
<p>YK: If you have a cycle, make sure the hoistable decls are evaluated ...?</p>
<p>BE: How observable?</p>
<p>BFS: In pure ESM, you never run code before it's completely linked, but when interacting with commonjs, we have to be able to execute some code earlier.</p>
<p>DH: ES2015 does not cope with dynamic modules.</p>
<p>BFS: If we have any interop, the distinctions between</p>
<p>BFS: let's go back instead of skipping ahead a bunch of slides</p>
<p>AWB: Need to understand differences between static and dynamic per spec.</p>
<p>BE/DH: need to address interop, dynamic code that can execute before link</p>
<p>BFS: CommonJS/ESM interop: conceptual distinctions are fundamentally at odds, material distinctions are at odds due to spec/implementation details</p>
<p>AWB: Conceptually, ESM is based around sharing bindings, whereas CJS is based on sharing values</p>
<p><img src="https://i.gyazo.com/2013ae96e120336c4677c561fec63507.png" alt=""></p>
<ul>
<li>Conceptual: intent or design goals that are fundamentally at odds</li>
<li>based on notes, records, design, etc.</li>
<li>Material: specification or implementation mandates that are at odds</li>
<li>based on things in reality</li>
</ul>
<p>WH: Why are conceptual and material required to be at odds by definition?</p>
<p>AWB: clarify? &quot;conceptually&quot; ES modules are based around sharing of &quot;bindings&quot; vs commonjs sharing of &quot;values&quot;</p>
<p>BFS: More than that</p>
<p>BFS: There's more than that in terms of conceptual differences</p>
<p>YK: We were intending for the loader to fill that gap</p>
<p>BFS: Conceptual difference: Mode detection: The spec expects things to be declared out of band; this could be a grammar change</p>
<p>BFS: Material: Some cases are ambiguous. This isn't the most important issue.</p>
<p>BFS: Cache data structures: We will have module maps analogous to browsers</p>
<p>DD: This is what enforces the idempotency</p>
<p><img src="https://i.gyazo.com/1f075f03f5f5c9cffcd3be00b634493a.png" alt=""></p>
<p><img src="https://i.gyazo.com/d50ec1630faf59996f0f720959701d86.png" alt=""></p>
<p>BE: Can you unload from this?</p>
<p>BFS: From given module record, import some string it's permanent: cannot remove it.</p>
<p>AWB: depends. linkage errors you could</p>
<p>BFS: expect to completely recreate your dep graph</p>
<p>AWB: once mod is instantiated and linked into the system, it's in. If not past the point of linking, then no one has seen it.</p>
<p>YK: the discussion on es-discuss could've gotten it wrong?</p>
<p>DD: There was a conceptual goal of idempotency</p>
<p>DH: A thing in the spec, but not especially understood.</p>
<p>DH: consequence of things dissappearing at error? avoid surprises. need complete control in your program. Not always automattically forced into reload policy. If the spec says reload, then issue.</p>
<p>DD: The spec doesn't lead to reloads; it leads to permanent not-reloads.</p>
<p>DH: Doesn't deleting from the cache cause a reload?</p>
<p>DD: the semantics say: once you get an error, you must cache that error forever</p>
<p>DH: Sounds like we should add more features for control here</p>
<p>YK: Is an issue that node needs to be things to go away</p>
<p>(fell behind)</p>
<p>BFS: example: a mocking library that wants to replace things in cache</p>
<p>JSL: The default behavior in Node is to get the same behavior back once it's initialized</p>
<p>BBR: We want to avoid many cases of getting two copies of modules, though it's not always possible, e.g., case-insensitive file system and different case names.</p>
<p>AWB: if you have file path: import a from path, you retrieve, link that in; subsequent import of the same string returns the same thing.</p>
<p>DH: clarify: a post resolve name?</p>
<ul>
<li>Can't specify anything about strings that appear in the</li>
</ul>
<p>(I didn't hear the end)</p>
<p>AK: Unfortunately, the spec does talk about those strings</p>
<p>AWB: What the spec says that if two strings are pointing to the same thing, it should be the same module</p>
<p>YK: We should fix the spec if needed</p>
<p>AWB: Want two identical paths to produce different modules</p>
<p>JSL: eg. mocks, instrumented modules</p>
<p>MRS: Some development tools explicitly control the cache, e.g., blow it away</p>
<p>AWB: things like repl loops are outside of the spec. But if you have two imports with identical strings, then under what circumstances would they produce different things?</p>
<p>DD: Discussion reiterates the following points a few times:
- Per spec, the only requirement is that if A imports &quot;x&quot; multiple times, it return the same module. There is no requirement on A importing &quot;x&quot; vs. B importing &quot;x&quot;.
- However, some people believe that the spec should be talking about the &quot;normalized&quot; or &quot;absolute&quot; form, not about the literal string (&quot;x&quot; above) that appears in the <code>import</code> statement.</p>
<p>AK: In the specification, the third bullet in <a href="https://tc39.github.io/ecma262/#sec-hostresolveimportedmodule">15.2.1.17</a> has the idempotency requirement. There is no normalization</p>
<p>This operation must be idempotent if it completes normally. Each time it is called with a specific referencingModule,specifier pair as arguments it must return the same Module Record instance.</p>
<p>(hostility towards note taking)</p>
<p>DH: Idempotency constraint not about source text, about result</p>
<p>WH: So where is the result used in the 15.2.1.17 HostResolveImportedModule •3 idempotency constraint? That line uses the string, not the result.</p>
<p>DD: Layering-wise, there's no way that we could enforce the idempotency requirement about any sort of normalized form, as this is done within the spec based on the name used to address the module in the source text.</p>
<p>DH: Thank you, good to know that the idempotency requirement is about the operation of HostResolveImportedModule, utterly impossible for node?</p>
<p>DD: the idempotency requirement is: if you have two <code>import &quot;x&quot;</code> in the same file, they must produce the same thing</p>
<p>DH: just a narrow constraint</p>
<p>YK: The intermediate string is where people are thinking about the api</p>
<p>BFS: This is a fine constraint for semantics</p>
<p>DD: Bradley's implementation is based on a map, as shown in his slides. The constraint of the spec means that,</p>
<p>if you want to use a map to satisfy this requirement</p>
<p>MRS: To get back to the core point, with Domenic's interpretation (i.e. that the spec only restricts that <code>import &quot;x&quot;</code> twice in the same file must return the same thing), are there any problems this?</p>
<p>BFS: No, no problem. We can implement this; I was just explaining what this is.</p>
<p>BFS: [Cache data structures slide]</p>
<p><img src="https://i.gyazo.com/d50ec1630faf59996f0f720959701d86.png" alt=""></p>
<p>BFS: Using <code>import()</code> to illustrate</p>
<p><img src="https://i.gyazo.com/6ab58a8d0a94937375e141b4240c7df1.png" alt=""></p>
<p>AWB: Remember that import sets up bindings</p>
<p>AK: The example would be identical if it said import &quot;f&quot;; import &quot;f&quot;; in semantics</p>
<p>BFS: The idempotency is prior to any evaluation. ESM import declaration links prior to evaluation, so idempotent prior to evaluation</p>
<ul>
<li>CJS declares its exports occur during or at the end</li>
</ul>
<p>AWB: Doesnt matter what you did for exports, nothing to link.</p>
<p>BFS: let's say I have <code>import &quot;foo&quot;</code></p>
<p>AWB: The difference between import and require is that require returns a value, so as long as you get the value, you have it, unlike linking bindings and pre-initializing them</p>
<p>BFS: The current feeling of how modules work is based on the Babel implementation, where that is not quite true. They use member expressions for variable access, rather than creating bindings</p>
<ul>
<li>using member expressions to simulate live bindings for variable access, not making bindings</li>
</ul>
<p>YK: Babel might be leaky, but it allowed people in node to do things that need to be understood</p>
<p>BFS: [Timing slide] ESM was designed for async loading, conceptually</p>
<p><img src="https://i.gyazo.com/deb57838dccb6937b8eb4b4e29704d0a.png" alt=""></p>
<p>AWB: My primary spec goal was static linking; I wasn't thinking about async linking at all</p>
<p>YK: AWB's spec is well written to separate the steps (re: sync and async are irrelevant)</p>
<p>BFS: To import CommonJS, you need to know their shape, which occurs during evaluation, after linking. For an ES module to import a CommonJS module, we need to hoist the evaluation of the CommonJS module into the linking phase</p>
<p>AWB: So if you want to treat a CJS module as an ESM, you can think of it as &lt;?&gt;</p>
<p>BFS: You still need to perform eval at some point</p>
<p>YK: b/c cjs modules need to be evaluated to know what the exports are, and have to evaluate esm, the cjs modules have to be run first (declarative vs. non)</p>
<p>DD: All agreed, evaluation has to happen first.</p>
<p>YK: CJS always treated as a single export</p>
<p>JM: <em>Do</em> have an object before evaluation, can be clobbered. You don't know the bindings ahead of time. If you import a CJS module from an ESM, you can make the semantics be that your lookup of the name is dynamic in a similar sense to the live bindings from ESM.</p>
<p>AWB: When import something from another module, taking bindings that aren't initialized</p>
<p>WH: What is <code>import *</code>?</p>
<ul>
<li><code>import *</code> doesn't import everything...</li>
</ul>
<p>DH: Doesn't exist anymore.</p>
<p>CP: If you happen to have a module that is not esm, can create binding that is default</p>
<p>BFS: These slides are based on the intent that we would have the same level of compatibility as Babel, where you can have named imports from CJS. We'd like to not lose that.</p>
<p>CP: not a requirement</p>
<p>YK: desirable</p>
<ul>
<li>Have to allow evaluation before linking</li>
</ul>
<p>DD: Allow him to get to the slides...</p>
<p>BFS: Without eval occurring during linking, we have no path to transition from transpilers to native modules.</p>
<p>BFS: [Timing example - Circular] Circular dependency between CJS and ESM, with <code>module.exports = null</code> from CJS</p>
<p><img src="https://i.gyazo.com/a36044bb7e3306007b007ddc9b87d6a1.png" alt=""></p>
<p>YK: Is this a realistic example?</p>
<p>JSL: Sometimes people do actually blow away exports from within the module</p>
<p>BFS: entry is our commonJS, dep is ESM. Dep tries to link, but entry's shape is not finalized. We can snapshot the shape at the end of the evaluation, but we can't link it earlier as we don't know the shape.</p>
<p><img src="https://i.gyazo.com/fbe3b4b28a7171f56ea077835f57cc79.png" alt=""></p>
<p>AWB: is the problem circ deps back to CJS?</p>
<p>BFS: You run into this sort of issue whenever you cross the bridge.</p>
<p>AWB: Requiring a dep starts a new root level load of the module. Not an import.</p>
<p>BFS: expectation is that esm cannot import cjs?</p>
<p>AWB: circularly.</p>
<p>DD: Could you clarify?</p>
<p>AWB: requires in context of esm cannot introduce circlularity because hey are binding based, not value based</p>
<p>DD: Can get an evaulation circularity</p>
<p>AWB: Can get a loop or an error</p>
<p>YK: banning cycles between cjs and esm seems more palatable</p>
<p>BFS: An alternate solution: Making loading esm from cjs an async op. This makes it so that you can't do eval circularly. This is a pretty drastic change, as some of your loading is async, so your whole dep graph is async</p>
<p>YK: would node consider disallowing cycles between cjs and esm?</p>
<p>BFS: Disallowing (throwing on attempt) was part of the original proposal</p>
<p>BBR: fine to drop support for circular deps?</p>
<p>JSL: Circular dependencies are actually very common with require. We cannot get rid of that. There is something to be said that, once we do an import, that we can't do a circular dependency back to require; maybe we can get rid of not allowing that</p>
<p>DH: This is not as drastic as getting rid of cycles altogether.</p>
<p>MRS: at scale?</p>
<p>BBR: Packages can actually be circular</p>
<p>MRS: essentially opting into once you have an import?</p>
<p>DD: Not the deps</p>
<p>DH: only within one package, if cjs package and want to migrate to esm: must migrate all within the package</p>
<p>DD: How does npm install circular package dependencies?</p>
<p>JS: It flattens the loop</p>
<p>DD: It would be interesting getting data on circular dependencies in npm packages</p>
<p>MRS: npm3 makes this worse by circularly depending on things flattening implicitly</p>
<p>JSL: There are multiple problems: When you do change the exports (insert explanation)</p>
<p>BFS: The two things which come up the most for Node CTC:
- Named imports being supported in whatever fashion for <code>import &lt;named thing&gt;</code> from CommonJS
- Can we do something synchronously? require(ESM) synchronously returns the module namespace object
That's mostly what this is about.</p>
<p>JSL: We could implement the spec as is. But this would make some compromises for the usability. With the current spec, these things wouldn't work.</p>
<p>DH: Design constraints:
- It needs to be possible to import named exports from CJS
- require(ESM) needs to synchronously</p>
<p>JM: Are these technical needs or ecosystem needs?</p>
<p>JSL: These are ecosystem needs. Babel today can do these things. Those users will want to be able to not change their code. If we say that doesn't work, we're violating a concern.</p>
<p>BB: People won't want to upgrade if they don't get synchronous <code>require</code></p>
<p>DD: Some of these things are up for debate; maybe it doesn't need to synchronously return</p>
<p>JSL: We could also let require this return a Promise</p>
<p>BM: Async is a way to get out of these issues, so you get out of &quot;the zebra striping problem&quot;.</p>
<p>(Do we need to be able to import CommonJS from EJS?)</p>
<p>JSL: Maybe we could sell, if it's a CommonJS, we can't import it.</p>
<p>MRS: That's easier to sell to Node people, but it's probably not what you want if you're an advocate of ESM. This will make the transition to ESL a hard sell for new users.</p>
<p>YK: any upgrade to esm, must break back compat.</p>
<p>JHD: a major semver release</p>
<p>DD: talking about named exports? If to make it work it would be an object not bindings? That's not a route we want to go</p>
<p>MRS: We're going to have mix of these two module systems for ever</p>
<p>DD: So, then do we want to get rid of static constraints?</p>
<p>DH: Do not want to throw away the guarantees from static constraints</p>
<p>AWB: With babel's loose interpretation of ESM, you're able to take a CJS module, apply its semantics, and it mostly works</p>
<p>BFS: It uses CJS under the hood, with ESM syntax</p>
<p>AWB: In the spirit of migrating, maybe just do exactly what Babel does?</p>
<p>BFS: are you suggesting we use the syntax of ESM, but not the semantics?</p>
<p>AWB: transpilation</p>
<p>YK: What node is discovering, esm and cjs is one big graph, other mdoules not considered</p>
<p>AWB: Babel translates ES module binding semantics into CommonJS value semantics</p>
<p>(discussion re: bridging from cjs to esm)</p>
<p>AWB: Not just syntax, fundamentally different semantics</p>
<p>BFS: But community things about modules as CJS</p>
<p>DH: concrete level: live bindings, aliasing</p>
<p>?</p>
<p>DD: Adding new properties or deleting old properties</p>
<p>YK: Changing exports by mutating properties</p>
<p>JSL: People mutate the object</p>
<p>AWB: With binding semantics, you can't look at a binding that hasn't been initialized. With value semantics, you look at everything as properties, you may see things as undefined</p>
<p>JSL: The community would really want named imports</p>
<p>BFS: We are here to discuss the problem. For timing, we have fixes, for named imports, we are here to discuss</p>
<p>JM: Sounds like we're going to break Babel somehow. We should be discussing how we will break Babel, but rather what's the way to break Babel that's minimally invasive.</p>
<p>YK: Could we make the exports object the default one, and sometimes make some of the bindings get additional redundant names?</p>
<p>DRR: as soon as named export plucking, make it non-trivial to move from cjs to esm. as soon as switched, one of two naive approaches.</p>
<p><a href="https://github.com/nodejs/node-eps/issues/26#issuecomment-230572661">https://github.com/nodejs/node-eps/issues/26#issuecomment-230572661</a></p>
<ul>
<li>(I'll ask Daniel to fill this in)</li>
<li>instead of assigning <code>module.exports</code>, I'll do <code>export function() {}</code> over and over</li>
</ul>
<p>JM: Third option, if there's no default export, Node could create one</p>
<p>MRS: It already does</p>
<p>YK: Maybe we could ask users to run a tool when upgrading</p>
<p>DRR: It would be hard to get the tool to be run</p>
<p>MRS: This would be a Python3-style incompatibility</p>
<p>BFS: skeptical that we can put in loader?</p>
<p>MRS: vast majority of modules will not be upgraded, more worried about these and users having expectations that they are</p>
<p>BBR: allow two different entry points, if package maintainer wants to do that?</p>
<ul>
<li>Or a tool that requires it, looks at the exports and creates a wrapper?</li>
</ul>
<p>BFS: Not sure?</p>
<p>BBR: We accept that there is no automatic transition</p>
<p>MRS: We want to avoid module authors doing any explicit work</p>
<p>BFS: If default is</p>
<p>DRR: (fill in point)</p>
<p>DH: important to look at named imports and exports that don't change, vs. do</p>
<p>MRS: (spoke to fast for me to follow, but basically something about <code>module.exports = function() {}</code>?)</p>
<p>BFS: If we had a way to observe mutations, we may be able to track them, but it's not clear how we would do that</p>
<p>YK: Empirically, most modules don't do mutation.</p>
<p>MRS: Module authors will get bugs reported to them that claim the issue is the new version of Node.</p>
<p>AWB: It's clear that all of the CJS and ESM lumped together will not work perfectly, but we can example things for use cases. Some may be automatic, others for tools, others impossible</p>
<p>MRS: We are trying to make these tradeoffs, but we want to make them in a sane manner; we want to look at whether which things would break the spec, or break what things on what end. We think users have a reasonable expectation to be able to do named imports from CJS modules. We will have to sacrifice some of the linking features in ESM, since Node's load cycle is a big block. We need to be able to break the tradeoff without violating the spec.</p>
<p>YK: approach, get as close to the spec as possible, and come back to the committee with concrete points that need to be fixed.</p>
<p>BFS: [Hoistable fix slide]</p>
<p><img src="https://i.gyazo.com/5f8b121af6cf3742ea6d81e0f1f6ac64.png" alt=""></p>
<p>BFS: you currently have access to calling the functions defined in a module even if you never evaluate it at all. In this proposal, that behavior would be removed, and you'd only get the functions if you really do it.</p>
<p>AWB: introducing new hypothetical API, need to define its semantics</p>
<p>DH: The observable difference is about whether you encounter</p>
<p>AWB: This only happens from circularities</p>
<p>AK: This is all about the interaction between circular dependencies between CJS and ESM</p>
<p>YK: Why care if esm can or cannot see cjs</p>
<p>BFS: We want a single module system that can be used for ES</p>
<p>I'm unable to type fast enough to keep up with this. Its hard to tease out the point when people start and stop statements mid-statement.</p>
<p>I want to explain, I'm going to, Here's how I think we can explain, let me unpack (interrupted)</p>
<p>DH: [suggesting some design where we &quot;delay validation&quot; of imports across module system boundaries]</p>
<p>AK: That would be a big change; it's hard to understand what that would mean.</p>
<p>DH: We may want to insert a lot more dynamism to solve this issue</p>
<p>MRS: How should ESM -&gt; CJS -&gt; ESM work?</p>
<p>CP: you would have a couple stripes when crossing the boundary</p>
<p>DH: That's why it's called zebra stripes</p>
<hr>
<p>(break)</p>
<p>BFS: Linking is very dynamic. The popular npm module &quot;meow&quot; relinks its parent. Used for CLI. When you require it, you get a new particular module per importer, which gives a modified version of it. We may need to revisit linking to support this.</p>
<p>WH: What does this achieve?</p>
<p>BFS: This lets you tool out your CLI without knowing anything about your dependent. It lets your dependency learn about your module by reading its package.json.</p>
<p>BFS: [Named imports slide] ESM cannot do named imports from CJS dependencies without mitigations. Our proposal is to hoist evaluation of the CJS module up to the linking phase.</p>
<p><img src="https://i.gyazo.com/58ca70760c349d34ffa72d156e83b032.png" alt=""></p>
<p>JSL: No matter what we do, we will break Babel somehow, the question is just how.</p>
<p>BFS: In our current proposal, we would take a snapshot of the exported properties of the object and export those names. We had considered more flexible behavior, but it seems unworkable.</p>
<p>CP: How many people are using this?</p>
<p>JSL, MRS: Some? It's unclear how many rely on it.</p>
<p><img src="https://i.gyazo.com/abf56ad5f940a8f89b19e96025e548b3.png" alt=""></p>
<p>MRS: We could say that it just doesn't work properly if you import it as ES6.</p>
<p>BFS: Common on npm: &quot;import {Component} from 'React'&quot;.</p>
<p>ESM Doable needs</p>
<ul>
<li><p>Context:</p>
<ul>
<li>Remove existing &quot;magic&quot; variables</li>
<li>Built-in module like <code>import {url} from 'js:context'</code> to get these variables -- defer to iterate on details, relates to discussion in Portland</li>
<li>Early errors from non-existent context variables</li>
</ul></li>
<li><p>Hooks:</p>
<ul>
<li>Need to ensure hookup prior to</li>
</ul></li>
<li><p>Some kind of loader spec, maintaining invariants of es262. May be related to the loader spec.</p></li>
</ul>
<p>----- Discussion
Context syntax details</p>
<p>BT: There was earlier discussion about import.context which would be a grab-bag object for these things like these, championed by Dave Herman at the Portland 2015 TC39 meeting</p>
<p>DE: If you want early errors, rather than getting undefined, then we could have <code>import.url</code> rather than <code>import.context.url</code> which would have an early error if you did <code>import.foobar</code>.</p>
<p>DD: It is important for this to be host-extensible and not introduce desktop concepts to the web</p>
<p>JSL: Yes, there should be compatibility between Node and the Web, and we'd be open to trying to move away from Node-specific APIs.</p>
<p>MSR: For extensibility, there are various cases, bundling loader, etc. These may hook into this in various ways.</p>
<p>YK: I'm concerned about compatibility with <strong>filename</strong> and <strong>dirname</strong></p>
<p>BFS: Although the spec would allow it, we will not modify the absolute URLs. The main thing we would need is import.url; we may want another path for CJS metadata, but no other properties shared between environments.</p>
<p>DH: I'm skeptical</p>
<p>MRS: dirname may be useful for a case where you have templates that you want to load from the directory where the JavaScript file is</p>
<p>DD: This could be based on require.resolve within the Node ecosystem</p>
<p>DH: In the loader spec work, there have been cases where import.url would not be such a clean thing to expose--for example, there could be two names that correspond to the same module.</p>
<p>import.resolve is another proposal for a pseudofunction, taking a string literal or possibly a runtime string value, for resolving the absolute, rather than relative, path which gives a more canonicalized way to reach the module, which would also be a thing that could be passed into import.</p>
<p>Generally: There is agreement in the room that getting the url and having a way to resolve an import into a url are important problems, and some subtle questions remaining about whether it should be a built-in module or pseudoproperty, as well as other details.</p>
<p>DH: New interoperability linking suggestion: The validation to linking would not always be performed statically, but rather dynamically when hitting a CJS module, and in that case, deferring the invalidation until the beginning of the execution of the top-level ESM module body. The next part is, what does the dynamic validation look like. One option is, we preserve live bindings from CJS, and the other option is a snapshot. The latter option guarantees nothing disappearing, but this loses the aliasing semantics of ES6. This is all for the case of importing a CJS from ESM.</p>
<p>BFS: There's a difference between snapshotting the list of property keys, and snapshotting the values of properties. I have proposed doing a live binding to the list of property keys which are available as one is exported from a CJS module after the initial evaluation, but to have bindings that are live from the CJS object to the module namespace object or direct usages</p>
<p>AK: The Babel version does have some notion of live binding [because it translates named lookups to member expressions on the exports object]</p>
<p>BFS: e.g., used in Promisify.all. Changing the values is much more common than changing the keys.</p>
<p>WH: Trying to pin things down. What is the specific evaluation order of an ESM module A importing from an ESM module B, and what exactly changes if B were a CJS module instead?</p>
<p>AK: [described DH's previous proposal involving delaying resolving bindings imported from CJS into an ESM until after CJS evaluates during evaluation]. Example:</p>
<p>// a
import {foo} from &quot;b&quot;;
import {bar} from &quot;c&quot;;</p>
<p>// b
export let foo = 1;
console.log('hello');</p>
<p>// c
console.log('world');
module.exports = { bar: 2 }</p>
<p>Instantiation of a causes instantiation of b, but because c is a CJS module we defer its &quot;instantation&quot; till later (and in the meantime put the &quot;bar&quot; binding in a into TDZ)
Evaluation of a immediately causes b to evaluate (before evaluating any of the statements in a), then c to evaluate, and after c evaluates we can complete linking of a to c, thus initializing &quot;bar&quot; to 2. If c failed to export &quot;bar&quot;, then an error would occur at this time (before any of a's statements execute).</p>
<p>DH: Another possibility, more ambitious: We may be able to allow cycles, based on some reordering. Disallowing cycles would be an adoption hazard. The proposal here would require the earlier modules to fully resolve before the later modules come.</p>
<p>JSL: Tools can create cycles that didn't exist</p>
<p>AK: How?</p>
<p>MRS: A downstream dependency may end up adding a dependency edge to something that uses it very indirectly, and a module in the middle of this cycle might not know about this but be affected</p>
<p>AK: Cycles would not work with the idea I was describing before as requiring the ESM from the CJS that imports it would hang, as require is synchronous and wants a fully-formed answer immediately. Options include CP's making the namespace object partial, or returning a Promise, or Dave's changing the evaluation order.</p>
<p>[AK: lots of discussion about a cyclical dependency graph involving CJS and ESM modules; q: how does evaluation order change? a: in several ways. q: do we know anything about the shape of the ESM modules themselves? a: not if there are StarExports that cross that boundary]</p>
<p>Prohibit export* of a CJS module from an ESM module.</p>
<p>BFS: We shouldn't return different shapes of modules at different times, e.g. if an ESM module imports a CJS module while CJS hasn't finished evaluating</p>
<p>JSL: We do support that in CJS right now, as a side-effect of how require works</p>
<p>AK: It should be a dynamic error to try to import * from a CJS module if that module is in a purgatory state</p>
<p>AWB: Or we could relax the immutability of module namespace objects in a case where the imported-from module is dynamic. The immutability was mostly for optimizability.</p>
<p>AK: Couldn't there also be security issues with allowing a namespace object to change after creation?</p>
<p>AWB: With everything being ESMs, we can do static resolution all the way down to the base binding. We can't necessarily do that when we have dynamic CJS modules in the middle there. We have to stop at that point. Seems like that requires a spec change. Ultimately, I think TDZs take care of it, but at present, in the ES spec, we assume that we can go all the way to the end, as opposed to going through multiple steps.</p>
<a href="#113a-import"><h2 id="113a-import">11.3.a import()</h2></a><p>(Domenic Denicola)</p>
<p><a href="https://github.com/domenic/proposal-import-function">https://github.com/domenic/proposal-import-function</a></p>
<p>DD: Presently, all module loading is done statically, top level. There are cases where you absolutely need to have conditional imports. There are many common use cases. Need to dynamically load a module, with a string. Returns a Promise for a module namespace object. The proposal keeps with out general stance of keeping proposals small; this is mostly syntax plus calling out to embedder hooks.</p>
<p>AWB: Does the occurrence of <code>import</code> turn the script into a module?</p>
<p>DD: Initially, I thought to restrict it to modules, but no reason to restrict it.</p>
<p>BFS: Many reasons to include for use in Node</p>
<p>DD: Good way to bootstrap into modules</p>
<p>AWB: Why special form, not a function?</p>
<p>BFS: To give you a context</p>
<p>DD: Want to be given a module specifier, e.g., for some embedders, a relative path which is resolved based on where you're calling this from.</p>
<p><a href="https://github.com/domenic/proposal-import-function#an-actual-function">https://github.com/domenic/proposal-import-function#an-actual-function</a></p>
<p><a href="https://github.com/domenic/proposal-import-function#a-new-binding-form">https://github.com/domenic/proposal-import-function#a-new-binding-form</a></p>
<p>DD: This is better than inserting <code>&lt;script type=module&gt;</code> tags dynamically because it's based directly on module specifiers, easier to use, doesn't pollute DOM, etc. Not introducing a new binding form.</p>
<p>DD: New embedder hook, HostFetchImportedModule (runtime equivalent of [[RequestedModules]])</p>
<p>WH: <code>import(</code> is not currently legal, so there's no ambiguity with import declarations</p>
<p>RW: Channeling DH from three years ago: <code>import(</code> creates confusion because it looks like a function but isn't a function.</p>
<p>DD: This is a syntactic form that's function-like. super is a prominent one. Also, you can do (x =&gt; import(x))</p>
<p>RW: That's a good precedent to cite for this (w/r to &quot;it looks like a function, but isn't actually a function object&quot;)</p>
<pre><code class="language-js"><span class="hljs-built_in">Promise</span>.all([<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>].map(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> <span class="hljs-keyword">import</span>(name)).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ...)
</code></pre>
<p>BFS: To clarify, even in Node, it would return a Promise</p>
<p>DD: Even if Node wants require to be synchronous, asynchronous background loading of modules is useful, e.g. lazily loading things from JSDOM.</p>
<p>MRS: In Node, we'd probably still do sync I/O and just return a Promise</p>
<p>BFS: Can still use require to <em>basically</em> this. The advantage to load the dep graph in a non-blocking way was explored via <code>require.async()</code> (pfft. whoops)</p>
<p>AWB: I was initially skeptical but like this proposal. Good for scripts, including for using built-in modules from scripts. Though you may want built-in modules to resolve synchronously.</p>
<p>AK: But it may take a long time to load the built-in module and want it to be asynchronous</p>
<p>AWB: Also, we could add the import statement to scripts</p>
<p>CP: Do you plan to allow require within module source text in Node?</p>
<p>BFS: Probably we'll have some way to get ahold of require, but we'd really encourage people to use import.</p>
<p>BB: Maybe you'd import require from a built-in module.</p>
<p>AK: Why is there a new hook for HostFetchImportedModule?</p>
<p>DE: Isn't this like adding something to [[RequestedModules]] dynamically?</p>
<a href="#conclusionresolution-113a-import"><h4 id="conclusionresolution-113a-import">Conclusion/Resolution</h4></a><ul>
<li>Stage 1</li>
<li>Becomes Stage 2 at the end of the day tomorrow, noting that we are seeking feedback from DH and YK which may affect this.</li>
<li>Reviewers</li>
<li>Caridy Patiño</li>
<li>Allen Wirfs-Brock</li>
<li>James Snell</li>
</ul>
<a href="#revisit-systemglobal--global"><h2 id="revisit-systemglobal--global">Revisit System.global =&gt; global</h2></a><p>JHD: Reviewers and editor have signed off on the spec text.</p>
<ul>
<li>Willing to make it <code>enumerable: true</code> pending implementor feedback</li>
</ul>
<p>JHD: Hope to have as many browser implementations before Stage 4</p>
<a href="#conclusionresolution-revisit-systemglobal--global"><h4 id="conclusionresolution-revisit-systemglobal--global">Conclusion/Resolution</h4></a><ul>
<li>Stage 3</li>
</ul>
<a href="#112b-intlsegmenter"><h2 id="112b-intlsegmenter">11.2.b Intl.Segmenter</h2></a><p>(Daniel Ehrenberg)</p>
<p>DE: Unicode defines breaking properties: grapheme, word, line, sentence breaks.</p>
<p><img src="https://i.gyazo.com/57e77bf6676eba9de26ff52fcf6bde5f.png" alt=""></p>
<ul>
<li>Want to remove <code>Intl.v8BreakIterator</code> (sorry about that!)</li>
</ul>
<p><img src="https://i.gyazo.com/e210324180f4fd426fe9104e3f058608.png" alt=""></p>
<pre><code class="language-js"><span class="hljs-comment">// Create a segmenter in your locale</span>
<span class="hljs-keyword">let</span> segmenter = <span class="hljs-built_in">Intl</span>.Segmenter(<span class="hljs-string">"fr"</span>, {<span class="hljs-attr">type</span>: <span class="hljs-string">"word"</span>});

<span class="hljs-comment">// Get an iterator over a string</span>
<span class="hljs-keyword">let</span> segmentIterator = segmenter.segment(<span class="hljs-string">"Ceci n'est pas une pipe"</span>);

<span class="hljs-comment">// Iterate over it!</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> {index, breakType} <span class="hljs-keyword">of</span> segmentIterator) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`index: <span class="hljs-subst">${index}</span> breakType: <span class="hljs-subst">${breakType}</span>`</span>);
  <span class="hljs-keyword">break</span>;
}
</code></pre>
<p>Short-cut accelerated API:</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> segmentIterator = segmenter.segment(
<span class="hljs-string">"Ceci n'est pas une pipe"</span>);

<span class="hljs-comment">// next() returning undefined</span>
segmentIterator.advance();

<span class="hljs-comment">// index of current break result</span>
segmentIterator.index();

<span class="hljs-comment">// breakType of current break result</span>
segmentIterator.breakType();
</code></pre>
<p>WH: Is the iterator the only API you're proposing? If you just wanted to turn a string into an array of words in that string, is there a quick way of doing that?</p>
<p>DE: For now just planning on providing the lower-level API. Things like that can be built on top of it.</p>
<p>JSL: Only works if you have full ICU (<code>Intl.v8BreakIterator</code>), ideal if this can be made to work with small ICU</p>
<p>WH: What does this do for indices at which there are no breaks? Does it have a concept of &quot;no break&quot;, or does it just omit them from the iterator output?</p>
<p>DE: It omits them.</p>
<p>WH:</p>
<pre><code><span class="hljs-built_in">Hello,</span> <span class="hljs-string">"world"</span>! \n\n
</code></pre>
<p>Where do the word breaks go here, and are the decisions configurable?</p>
<p>DE: Explained in <a href="http://unicode.org/reports/tr29/">http://unicode.org/reports/tr29/</a> (UAX29)</p>
<p>WH: Might be nice to also include a segmenter that indicates character boundaries; i.e., everywhere except between UTF16 surrogate pairs.</p>
<p>AWB: Intl standard-optional, not standard-mandatory</p>
<ul>
<li>Is this functionality something that you want tied to the optionality?</li>
</ul>
<p>BT: grapheme doesn't require a lot of data</p>
<p>DE: The advice is: callout to ICU or you'll do it wrong</p>
<p>BT: is Segmenter based on UAX29?</p>
<p>DE: Both UAX29 and UAX14</p>
<p>Mixed discussion about ICU data, etc. Dan answers all questions.</p>
<p>SYG: cannot reverse a string and get same breaks</p>
<p>WH: Reversing doesn't make a difference. In either the forward or reverse case you may need arbitrarily long lookahead and lookbehind to determine the breaks. For example, there are emoji grapheme breaking rules that state that if you have an even number of characters preceding your position then you have a break, but if you have an odd number then you don't. So you need to consider the input string as a whole.</p>
<p>WH: UAX29 lists lots of configuration sub-options for different kinds of breaking choices. Is it your intent to support those?</p>
<p>DE: Yes.</p>
<p>JSL: ideal to get rid of prefixed.</p>
<a href="#conclusionresolution-112b-intlsegmenter"><h4 id="conclusionresolution-112b-intlsegmenter">Conclusion/Resolution</h4></a><ul>
<li>Stage 1</li>
</ul>

</body>