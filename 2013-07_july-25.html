<!doctype html>
<meta charset="utf-8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.6.0/github-markdown.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/javascript.min.js"></script>

<title>July 25, 2013 Meeting Notes</title>
<body class="markdown-body">
<a href="#july-25-2013-meeting-notes"><h1 id="july-25-2013-meeting-notes">July 25, 2013 Meeting Notes</h1></a><hr>
<p>John Neumann (JN), Luke Hoban (LH), Rick Hudson (RH), Allen Wirfs-Brock (AWB), Yehuda Katz (YK), Anne van Kesteren (AVK), Jeff Morrison (JM), Sebastian Markbåge (SM), Alex Russell (AR), István Sebestyén (IS), Mark S. Miller (MM), Norbert Lindenberg (NL), Erik Arvidsson (EA), Waldemar Horwat (WH), Eric Ferraiuolo (EF), Matt Sweeney (MS), Doug Crockford (DC), Rick Waldron (RW), Rafeal Weinstein (RWN), Dmitry Lomov (DL), Brendan Eich (BE), Ian Halliday (IH), Paul Leathers (PL),</p>
<hr>
<a href="#56-can-letconstclassfunction-in-non-strict-code-bind-eval-and-arguments"><h2 id="56-can-letconstclassfunction-in-non-strict-code-bind-eval-and-arguments">5.6 Can let/const/class/function* in non-strict code bind &quot;eval&quot; and &quot;arguments&quot;</h2></a><p>(Allen Wirfs-Brock)</p>
<p>AWB: Currently, only var and function have any rules: non-strict is not</p>
<p>YK: Reduce the refactoring hazards</p>
<p>MM: What happens in arrows?</p>
<p>EA: Formal params follow the strict rules (no duplicates, no param named arguments etc), but the bodies are not strict.</p>
<p>RW/BE: Confirm</p>
<p>AWB: If someone writes...</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">eval</span> </span>{}
</code></pre>
<p>And later moves this to a module...</p>
<pre><code class="language-js"><span class="hljs-built_in">module</span> <span class="hljs-string">"foo"</span> {
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">eval</span> </span>{}
}
</code></pre>
<p>This will blow up</p>
<p>RW: But the same issue exists if:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eval</span>(<span class="hljs-params"></span>) </span>{}
</code></pre>
<p>And later moves this to a module...</p>
<pre><code class="language-js"><span class="hljs-built_in">module</span> <span class="hljs-string">"foo"</span> {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eval</span>(<span class="hljs-params"></span>) </span>{}
}
</code></pre>
<p>MM, WH: We need to make sure that whatever rule we decide on, is the simplest and easiest to remember</p>
<p>BE: Recall the issue of micro-modes</p>
<p>BE: Based on the decision make Arrows non-strict, the same reasoning applies to params</p>
<p>EA: Strict formal parameters are an early error, strict function body have different runtime semantics so those are a refactorig hazard.</p>
<p>AWB: The spec draft uses StrictFormalParameter for ArrowFunction and MethodDefinition.</p>
<p>YK: Easy to get sanity, by opting into modules and classes</p>
<p>RW: The January notes include rationale regarding the boundary of module and class, but not arrow, there is no note about arrow params being implicitly strict mode</p>
<p>AWB: method names in sloppy mode (object literals) do not allow duplicat names.</p>
<p>YK: Seems OK.
... Code may exist that has methods called &quot;eval&quot; or duplicate params named &quot;_&quot;</p>
<p>MM:</p>
<ul>
<li>eval &amp; arguments</li>
<li>duplicate arrow &amp; method params</li>
<li>duplicate non-data names in object literals</li>
</ul>
<p>LH: Agrees that these rules should be applied where code opts-in, not by layered addition of language features</p>
<p>MM: Agrees with LH, in terms of the memory burden (developer end). This wont be clear to anyone but us.</p>
<ul>
<li>If you're in non-strict, it should act non-strictly</li>
</ul>
<p>BE/RW: Yes</p>
<p>Various: explored the consequences of allowing duplicate method parameters even in new-style parameter lists when in non-strict mode. That would be the simplest rule, but it would cause too many edge cases for duplicate parameter names in destructuring, rest parameters, etc., so we all agreed not to pursue that approach.</p>
<p>AWB: The rule that we agreed on, in that past is that when new syntax forms are involved.</p>
<ul>
<li>Depends on form of the parameter list</li>
</ul>
<p>MM: We need to lower the memory burden</p>
<p>EA: This is going to make it greater</p>
<p>MM: Defending exception for new forms of parameter list.</p>
<p>AWB: More complex set of rules if you allow multiple names in simple parameter lists.</p>
<ul>
<li>Duplicate param names not allowed, except for function definitions (things declared with function) with simple parameter lists</li>
</ul>
<p>MM: That's more complex</p>
<a href="#consensusresolution-56-can-letconstclassfunction-in-non-strict-code-bind-eval-and-arguments"><h4 id="consensusresolution-56-can-letconstclassfunction-in-non-strict-code-bind-eval-and-arguments">Consensus/Resolution</h4></a><ul>
<li>General Rule:
<ul>
<li>Non-strict code operates in consistently non-strict manner (This covers the let/const/function* cases)</li>
<li>Exception:</li>
<li>Only allow duplicate parameter names in simple parameter lists</li>
<li>Simple parameter lists are defined by those that do not include rest or defaults or destructuring.</li>
</ul></li>
<li>Consensus: The name of the ClassDeclaration/ClassExpression follows the strict rules for its name. So it cannot be named &quot;eval&quot; or &quot;arguments&quot;. Just like for strict function names.</li>
</ul>
<a href="#59-semantics-and-bounds-of-numberisinteger-and-numbermax_integer"><h2 id="59-semantics-and-bounds-of-numberisinteger-and-numbermax_integer">5.9 Semantics and bounds of Number.isInteger and Number.MAX_INTEGER</h2></a><p>(Allen Wirfs-Brock, originally proposed by Doug Crockford?)</p>
<p>AWB: What is the value of MAX_INTEGER</p>
<p>WH; Whatever the largest finite double</p>
<p>DC: But there are two</p>
<p>WH: But I said &quot;double&quot;</p>
<p>DC: That's ambiguous</p>
<p>WH: No</p>
<p>MM: WH is not constraining to the contiguous range.</p>
<p>WH: If you want 2^53, call it something else</p>
<p>MM: Likewise with isInteger
...Propose:</p>
<pre><code>Number.MAX_SAFE_INTEGER = 2^53-1
Number.isSafeInteger =&gt; n &gt; -(2^53)
</code></pre>
<p>AWB:</p>
<pre><code>2^53-1, 2^53, 2^53+2

2^53+1 === 2^53
</code></pre>
<p>After 2^53, you can add 2</p>
<p>WH: Alternate proposal:</p>
<pre><code>Number.MAX_CONTIGUOUS_INTEGER = 2^53
Number.isContiguousInteger = n =&gt; n &gt;= -(2^53) &amp;&amp; n &lt;= (2^53);
</code></pre>
<p>MM: Gives history of &quot;isSafeInteger&quot;</p>
<p>Caja had a Nat test that tested that a number was a primitive integer within the range of continguously representable non-negative integers. I used Nat in a small piece of security critical code, to ensure I was doing accurate integer addition and subtraction. Because I was using this definition, Nat admitted 2^53. This introduced a security hole, which escaped notice in a highly examined piece of code which has been published several times and has been the subject of several exercises to do machine checked proofs of some security properties. Despite all this attention and examination, no one caught the vulnerability caused by admitting 2^53. By excluding 2^53, we have the nice invariant that if</p>
<p>isSafeInteger(a)
isSafeInteger(b)
isSafeInteger(a+b)</p>
<p>are all true, then (a+b) is an accurate sum of a and b.</p>
<p>WH: OK</p>
<p>DC: Want to call this Integer</p>
<p>WH: Can't call this integer. 2^54 is an integer, just not inside of the contiguous range. Like the concept, but not ok to name it &quot;isInteger&quot;, as 2^100 also happens to be an integer.</p>
<p>BE: Agrees with Mark's &quot;Safe&quot;</p>
<p>YK: Easy to explain that Integers outside of the range</p>
<p>AWB: Current spec checks for mathematical integer</p>
<p>...toInteger makes use of internal ToInteger</p>
<p>MM: Makes sure there is no fractional part?</p>
<p>WH: Yes</p>
<p>WH: If we have toInteger, then we need isInteger or isSafeInteger</p>
<p>AWB:</p>
<p>isInteger
isSafeInteger</p>
<p>MM:</p>
<p>MAX_SAFE_INTEGER = (2^53)-1</p>
<p>isInteger</p>
<ul>
<li>Infinity =&gt; false</li>
<li>NaN =&gt; false</li>
<li>value !== truncated value =&gt; false</li>
<li>-0 =&gt; true</li>
</ul>
<p>isSafeInteger</p>
<ul>
<li>-0 =&gt; true</li>
</ul>
<p>toInteger</p>
<ul>
<li>Does not guarantee a safe integer</li>
</ul>
<p>ToInteger</p>
<ul>
<li>Does not guarantee a safe integer</li>
</ul>
<p>WH: The only place where ToInteger is divergent is +/-Infinity</p>
<p>WH: We already have Math.trunc, which does the same thing as ToInteger would. Don't need Number.toInteger.</p>
<a href="#58-numberprototypeclz-or-mathclz"><h2 id="58-numberprototypeclz-or-mathclz">5.8 Number.prototype.clz or Math.clz?</h2></a><p>WH/AWB: Is an instance operation.</p>
<p>WH: If it's on Math.clz(), it will return the wrong answer if we have different value objects in the future</p>
<p>WH:  In particular, this specifies that the value is 32 bits wide, which  makes it inappropriate as something in Math. Consider what happens if we add a uint64 type. Then we'd want Uint64.clz to count starting from the  64th bit instead of from the 32nd bit. We can do that if it's  Uint64.clz. We can't (without creating weirdness) if we use Math.clz for  both.</p>
<p>AWB: Then it belongs on the instance side.</p>
<p>Any objections?</p>
<a href="#consensusresolution-58-numberprototypeclz-or-mathclz"><h4 id="consensusresolution-58-numberprototypeclz-or-mathclz">Consensus/Resolution</h4></a><ul>
<li>Number.prototype.clz</li>
</ul>
<p>AWB: What about the following:</p>
<pre><code>Number.isInteger
Number.isSafeInteger
Number.isFinite
Number.isNaN
Number.toInteger
</code></pre>
<a href="#consensusresolution-58-numberprototypeclz-or-mathclz"><h4 id="consensusresolution-58-numberprototypeclz-or-mathclz">Consensus/Resolution</h4></a><p>Remove Number.toInteger (already exists as Math.trunc)</p>
<p>(Reference: <a href="https://github.com/rwldrn/tc39-notes/blob/42cf4dd15b0760d87b35714fa2e417b589d76bdc/es6/2013-01/jan-29.md#conclusionresolution-1">https://github.com/rwldrn/tc39-notes/blob/42cf4dd15b0760d87b35714fa2e417b589d76bdc/es6/2013-01/jan-29.md#conclusionresolution-1</a>)</p>
<a href="#513-which-existing-built-in-properties-that-are-read-onlynon-configurable-do-we-want-to-make-read-onlyconfigurable"><h2 id="513-which-existing-built-in-properties-that-are-read-onlynon-configurable-do-we-want-to-make-read-onlyconfigurable">5.13 Which existing built-in properties that are read-only/non-configurable do we want to make read-only/configurable?</h2></a><p>(Allen Wirfs-Brock)</p>
<p>AWB: Previously, we've discussed setting data properties as {writable: false, configurable: true}</p>
<p>One of these built in properties that discussed is the length property of function</p>
<p>MM: Points about function properties, eg. the prototype property</p>
<p>EA: Classes are a constructor and the prototype, can't use function for the argument to how classes behave</p>
<p>MM: Don't think this is a question that should be addressed for ES6, it's too late.</p>
<p>AWB: Not too late, we've discussed this</p>
<p>AWB: The &quot;prototype&quot; property of the class constructor object is configurable, non-writable</p>
<p>AWB: {writable: false, configurable: true} allows enough control</p>
<p>EA: We also discussed this for methods</p>
<p>YK: This is part of the refactoring hazard I mentioned earlier.</p>
<p>MM: Don't want to consider a change of that magnitude this late in the game</p>
<p>AWB: All of the existing properties from ES5, should we address the whole list?</p>
<ul>
<li></li>
</ul>
<p>When define a class:</p>
<pre><code>(Foo.prototype) -C-&gt; &lt;-P- (Foo)
</code></pre>
<p>AWB: Foo.prototype.constructor property {writable: false, configurable: true}?</p>
<p>MM: This hazard:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>) </span>{}
Bar.prototype = <span class="hljs-built_in">Object</span>.create(Foo.prototype);
Bar.prototype.constructor = Bar;
</code></pre>
<p>Code that exists like this, once Foo gets refactored to a class, if constructor is non-writable, the above breaks.</p>
<p>AWB: <a href="https://github.com/rwldrn/tc39-notes/blob/42cf4dd15b0760d87b35714fa2e417b589d76bdc/es6/2013-01/jan-29.md#48-refactored-new-operator-and-the-create-method">@@create</a></p>
<pre><code class="language-js"><span class="hljs-built_in">Array</span>[@@create]
</code></pre>
<p>Recap:</p>
<pre><code>@@create sets the prototype property of the new instance, but referencing the prototype property of the constructor itself.
</code></pre>
<p>MM: With regard to function.name and function.length and making them &quot;tamper resistant&quot;, but mucking around with the built-in prototype chain has unknown implications and it could be addressed in ES7.</p>
<p>This change allows the actual Array.prototype to be changed.</p>
<p>WH: When does @@create get called?</p>
<p>AWB: when <code>new</code> is used.</p>
<a href="#consensusresolution-513-which-existing-built-in-properties-that-are-read-onlynon-configurable-do-we-want-to-make-read-onlyconfigurable"><h4 id="consensusresolution-513-which-existing-built-in-properties-that-are-read-onlynon-configurable-do-we-want-to-make-read-onlyconfigurable">Consensus/Resolution</h4></a><p>{writable: false, configurable: true}?</p>
<ul>
<li>length property of functions: yes</li>
<li>prototype property of functions: no</li>
<li>new properties, ie. @@create: yes</li>
</ul>
<a href="#tc39--w3c"><h2 id="tc39--w3c">TC39 + W3C</h2></a><p>Discussion joint meeting with W3C at TPAC, Nov 11-15, in Shenzhen, China.</p>
<a href="#51-symbol-primitive-value-or-object-one-more-time"><h2 id="51-symbol-primitive-value-or-object-one-more-time">5.1 Symbol primitive value or object? One more time.</h2></a><p>(Allen Wirfs-Brock)</p>
<p>EA: There is discontent that there isn't private state. Symbols don't cover this. Unique Strings solve the uniqueness case</p>
<p>Proposal:
Postpone Symbols to ES7</p>
<p>BE: The reason we seperated private and unique was exposure in Reflection modules</p>
<p>YK: You don't need unique symbols when you can just expose private symbols.</p>
<p>MM: The @@iterator symbol must be transitively immutable</p>
<p>In the relationships case, the WeakMap</p>
<p>BE: There are classes that outlive any instances</p>
<p>Why can't we just have (private) Symbols</p>
<p>MM: Two subsystems that aren't supposed to be able to communicate with each other should be able to share anything that is transitively immutable.</p>
<p>BE: Can we unwind the split between private and unique?</p>
<p>YK: (fill this in)</p>
<p>AWB: We deferred private symbols</p>
<p>Private state should not be mixed up with Private Symbols</p>
<p>Symbols are guaranteed uniqueness, wrong way to go for private state.</p>
<p>BE: We aren't going to resolve this now, need to take it to es-discuss</p>
<p>AWB: For the spec, how do I spec Symbols?</p>
<p>Strings won't guarantee</p>
<p>MM/BE: (quick discussion about uuid strings)</p>
<p>WH: What you're saying is that we need a gensym?</p>
<p>AWB: Essentially, what we need is a gensym</p>
<p>BE: Andreas implemented Symbol</p>
<p>AWB: Dug in against wrapper objects for Symbols</p>
<ol>
<li><p>(did someone catch this one)?</p></li>
<li><p>Unique objects, unforgeable, can't set or access properties. Are actually objects.</p></li>
</ol>
<p>BE: ARB says that v8 internal architecture makes it hard to add new</p>
<a href="#consensusresolution-51-symbol-primitive-value-or-object-one-more-time"><h4 id="consensusresolution-51-symbol-primitive-value-or-object-one-more-time">Consensus/Resolution</h4></a><ul>
<li>Leave the spec as it is now</li>
<li>Postpone until next f2f</li>
</ul>
<a href="#512-should-we-remove-construct-from-the-mop-and-proxy-handler-api"><h2 id="512-should-we-remove-construct-from-the-mop-and-proxy-handler-api">5.12 Should we remove [[Construct]] from the MOP and Proxy handler API?</h2></a><p>(Allen Wirfs-Brock)</p>
<p>AWB: recapping @@create changes...</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> C(...args);
</code></pre>
<p>Essentially breaks down to:</p>
<pre><code class="language-js">[[Construct]] =&gt;

<span class="hljs-keyword">let</span> obj = C[@@create]();

<span class="hljs-keyword">return</span> C.[[Call]](obj, ...args);
</code></pre>
<p>YK: This means that [[Construct]] will always call [[Call]].</p>
<p>AWB: The way the built-ins work, override @@create, eg. Date, creates a private data slot for the time</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">String</span>(<span class="hljs-params">value</span>) </span>{
<span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> has an unitialized instance)) {
<span class="hljs-keyword">return</span> <span class="hljs-string">""</span> + value;
}

     <span class="hljs-keyword">this</span>.value = <span class="hljs-string">""</span> + value
}

<span class="hljs-built_in">String</span>[@@create] =&gt; { <span class="hljs-attr">value</span>: uninitialized instance }

</code></pre>
<p>WH: Disapproves having String when called as a function do different things based on this. This breaks the invariant that String(x) always returns a primitive string.</p>
<p>WH, MM: Also concerned about adding a new uninitialized String instance type as a specing helper but which becomes reified and user-visible. Someone could call String's @@create directly, obtain one of these values, and cause mayhem. Too much surface area of potential problems here, and this is unnecessary complexity.</p>
<p>YK: Objects to removal [[Construct]]</p>
<p>AWB: A Proxy trap?</p>
<p>BE/YK: Keep</p>
<a href="#consensusresolution-512-should-we-remove-construct-from-the-mop-and-proxy-handler-api"><h4 id="consensusresolution-512-should-we-remove-construct-from-the-mop-and-proxy-handler-api">Consensus/Resolution</h4></a><ul>
<li>[[Construct]] remains.</li>
</ul>
<a href="#anti-pattern-to-call-a-constructor-without-new"><h2 id="anti-pattern-to-call-a-constructor-without-new">Anti-Pattern to call a constructor without new</h2></a><p>(Allen Wirfs-Brock)</p>
<p>AWB: In ES6, with class, it will be an anti-pattern... Don't call without &quot;new&quot;</p>
<p>BE: This is style/convention</p>
<p>Promote the use of <code>new</code> with classes</p>
<p>MM: Might want a constructor to refuse to initialize an instance of that class if the call object is not the</p>
<p>EA: Three browsers have implemented Map, Set, WeakMap, WeakSet and all are allowed to be called without <code>new</code>, which breaks subclassing</p>
<p>General agreement that this is bad.</p>
<p>AWB/MM: Function.prototype.@@construct</p>
<p>MM: If it implies runtime overhead that is not easily optimized, that would be a perfectly valid argument against. Does it?</p>
<p>In general, wherever we can replace a [[Foo]] internal property with an @@foo unique symbol named property, without penalty, we should. Especially if proxies would otherwise need a special trap for [[Foo]].</p>
<p>YK: Need to be careful when we change the MOP since other specs refers to the mop methods.</p>
<a href="#consensusresolution-anti-pattern-to-call-a-constructor-without-new"><h4 id="consensusresolution-anti-pattern-to-call-a-constructor-without-new">Consensus/Resolution</h4></a><ul>
<li>Giving up on the convenience of calling constructors without new, with any expectation</li>
<li>Throw when Map, Set, WeakMap, WeakSet are called without <code>new</code></li>
</ul>
<a href="#json"><h2 id="json">JSON</h2></a><p>Any objections to sending the JSON draft 7 version to the general assembly</p>
<p>DC: Made changes. Specifiy code point. Removed summary of grammar. It was redundant. As well as the whitespace issue.</p>
<p>JN: Send proposal to ???. If you don't reply to this thread then it is an implicit approval.</p>
<a href="#62-interfacing-ecmascript--htmldom-event-loops"><h2 id="62-interfacing-ecmascript--htmldom-event-loops">6.2 Interfacing ECMAScript &amp; HTML/DOM Event Loops</h2></a><p>(Rafael Weinstein)</p>
<p>RWN: (A single slide) How does ES inegrate with the rest of the specified environment with regard to scheduling tasks.</p>
<ul>
<li><p>Enqueue A Task</p></li>
<li><p>The environment <em>must</em> run the task at some point in the future</p></li>
<li><p>The task <em>must</em> be run <strong>after</strong> <strong>all</strong> previous enqueued tasks</p></li>
<li><p>The task <em>must</em> be run on an empty stack.</p></li>
<li><p>Enqueue A Microtask</p></li>
<li><p>The environment <em>must</em> run the microtask at some point in the future</p></li>
<li><p>The microtask <em>must</em> be run <strong>before</strong> <strong>all</strong> previously enqueued tasks</p></li>
<li><p>The microtask <em>must</em> be run <strong>after</strong> <strong>all</strong> previously enqueued microtasks</p></li>
<li><p>The microtask <em>must</em> be run on an empty stack</p></li>
</ul>
<p>WH: Note that this defines a total order.</p>
<p>MM: We need to decide how tasks or microtasks that originate from EcmaScript behave</p>
<p>MM: No nested event loop?</p>
<p>General agreement that the ES spec not support nested event loops. If the browser specs require them, i.e., for running JS code while a modal dialog is blocked, then the browser specs would need to state that this is an intended violation of the ES event loop model.</p>
<p>YK: Timing is another issue</p>
<p>MM: Promise scheduling, fifo</p>
<p>Discussion re: the host vs.</p>
<p>w3c bug...</p>
<a href="#consensusresolution-62-interfacing-ecmascript--htmldom-event-loops"><h4 id="consensusresolution-62-interfacing-ecmascript--htmldom-event-loops">Consensus/Resolution</h4></a><ul>
<li>Needs more offline discussion</li>
</ul>
<a href="#value-objects-update"><h2 id="value-objects-update">Value Objects Update</h2></a><p>(Brendan Eich)
ValueObjects.pdf</p>
<p>BE:</p>
<p>Use Cases:</p>
<ul>
<li>Symbol</li>
<li>int64, uint64 (53 bits not enough)</li>
<li>Int32x4, Int32x8 (SIMD)</li>
<li>float32</li>
<li>Float32x4, Float32x8 (SIMD)</li>
<li>gignum</li>
<li>decimal</li>
<li>rational</li>
<li>complex</li>
</ul>
<p>Overloadable Operators</p>
<ul>
<li>| ^ &amp;</li>
<li>==</li>
<li>&lt; &lt;=</li>
<li>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</li>
<li><ul>
<li><ul>
<li></li>
</ul></li>
</ul></li>
<li><ul>
<li>/ %</li>
</ul></li>
<li>~ boolean-test unary- unary+</li>
</ul>
<p>Preserving Boolean Algebra</p>
<ul>
<li>!= and ! are not overloadable to preserve identities including</li>
<li>X ? A : B &lt;=&gt; !X ? B : A</li>
</ul>
<p>... Too fast, request slides.</p>
<p><a href="http://www.slideshare.net/BrendanEich/value-objects">http://www.slideshare.net/BrendanEich/value-objects</a></p>
<p>&quot;complex and rational cannot be composed to make ratplex&quot;</p>
<p>AVK: Multiple globals will cause issues.</p>
<p>BE: That is not an issue with this proposal. It is an issue with multiple globals.
... we need literal syntax for readability.
... no solution for user defined literal suffixes.</p>
<p>BE: Some have requested mutable value objects in order to represent small tuples and be able to do updates on them in a loop.</p>
<p>WH: This no more requires value objects to be mutable than incrementing a loop counter requires integers to be mutable. It's the variable that holds the integer 3 that's mutable and an be changed to refer to a different integer; you can't change the integer 3 itself to be 5. If the value is a small tuple and the source and destination are the same, it's easy enough for a compiler to transform a functional-style tuple update into imperative code if it likes.</p>
<p>WH, MM: Don't want mutable number literals/objects. No <code>new Float32x4(a, b, c, d)</code>. This would break === (which would then need to do identity matching instead of same-value matching).</p>
<pre><code class="language-js">
<span class="hljs-keyword">typeof</span> x == <span class="hljs-keyword">typeof</span> y &amp;&amp; x == y
  &lt;=&gt;
x === y

<span class="hljs-number">0</span>m === <span class="hljs-number">0</span>
<span class="hljs-number">0</span>L == <span class="hljs-number">0</span>
<span class="hljs-number">0</span>m == <span class="hljs-number">0</span>L
</code></pre>
<p>BE: typeof become advisory</p>
<p>AWB: You can register typeof result once during registration. That way we can enforce that it does not changes.</p>
<a href="#consensusresolution-value-objects-update"><h4 id="consensusresolution-value-objects-update">Consensus/Resolution</h4></a><ul>
<li>NaN requires separately overloadable &lt;= and &lt; [Slide 5]</li>
<li>Intersection means function identity matters, so multimethods can break cross-realm [Slide 9]</li>
<li>Mark objects that I or i as bignum suffix conflicts with complex [Slide 11].</li>
<li>Always throw on new -- value objects are never mutable and should not appear to be so, even if aggregate [Slide 12]</li>
<li>Need to work through any side channel hazard of the typeof registry [Slide 13] and the multimethod dispatch &quot;registry&quot;</li>
</ul>
<a href="#65-parallel-javascript-river-trail"><h2 id="65-parallel-javascript-river-trail">6.5 Parallel JavaScript (River Trail)</h2></a><p>(Rick Hudson)
...need slides</p>
<p>RH: We have to go parallel to keep up with other langauages</p>
<p>YK: Don't want to fallback into sequential</p>
<p>Various: Debate about what happens when the parallel computations have side effects that introduce dependencies between them. Options are either devolving into sequential computation or throwing an exception.</p>
<p>RH: The code behaves the same way as sequential code but goes faster if there are no side effects.</p>
<p>WH: What happens if there are no side effects but some of the computations throw exceptions? Which exception do you get?</p>
<p>RH: Any of them. There are also other implementation options here.</p>
<p>WH: If it's any of them, then this is not like sequential code.</p>
<p>WH: What exactly is a side effect? How would a programmer know that some ECMAScript construct has an internal side effect?</p>
<p>WH: In particular, suppose that I want to use a parallel loop to fill a big matrix with random numbers. Is calling a random number generator considered to be a side effect or not? If the answer is yes (it is a side effect), then how would one fill a big matrix with random numbers in parallel, as that is something that one would reasonably want to be able to do?</p>
<a href="#consensusresolution-65-parallel-javascript-river-trail"><h4 id="consensusresolution-65-parallel-javascript-river-trail">Consensus/Resolution</h4></a><ul>
<li>Throw instead of falling back to sequential.</li>
<li>Focus on concurrency/scheduling in ES7. Make sure it fits with other concurrency constructs (promises/event queues)</li>
<li>Discussion/Acceptance in ES7 process.</li>
</ul>
<a href="#rws-proposal-for-specification-process-for-es7-process"><h2 id="rws-proposal-for-specification-process-for-es7-process">RWS Proposal For Specification Process (for ES7 process)</h2></a><a href="#consensusresolution-rws-proposal-for-specification-process-for-es7-process"><h4 id="consensusresolution-rws-proposal-for-specification-process-for-es7-process">Consensus/Resolution</h4></a><ul>
<li>Go forth</li>
</ul>
<a href="#7-internationalization"><h2 id="7-internationalization">7 Internationalization</h2></a><p>NL: Implementations of ECMAScript Internationalization API:
- Microsoft has shipped it in Internet Explorer 11 beta
- Opera has shipped it in Opera 15 (based on Chromium)</p>
<a href="#future-meetings"><h2 id="future-meetings">Future Meetings</h2></a><p>Sept 17-19, Boston
Nov 19-21, San Jose</p>

</body>