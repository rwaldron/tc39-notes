<!doctype html>
<meta charset="utf-8">
<link rel="apple-touch-icon" sizes="180x180" href="img/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="img/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="img/favicon-16x16.png">
<link rel="manifest" href="img/site.webmanifest">
<link rel="mask-icon" href="img/safari-pinned-tab.svg" color="#5bbad5">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.6.0/github-markdown.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/javascript.min.js"></script>
<title>June 4, 2019 Meeting Notes</title>
<body class="markdown-body">
<a href="javascript:history.back()">Back</a>
<a href="#june-4-2019-meeting-notes"><h1 id="june-4-2019-meeting-notes">June 4, 2019 Meeting Notes</h1></a><hr>
<p>Istvan Sebestyen (IS), Valerie Young (VYG), Pieter Ouwerkerk (POK), Noah Tye (NTE), Philipp Dunkel (PDL), Aki Rose (AKI), Myles Borins (MBS), Mathias Bynens (MB), , Randy Luecke (RCL), Daniel Ehrenberg (DE), Till Schneidereit (TST), Patrick Soquet (PST), Peter Hoddie (PHE), Mattijs Hoitink (MHK), Keith Miller (KM), Michael Saboff (MS), Mark Miller (MM), Guilherme Hermeto (GHO), Sathya Gunasekaran (SGN), Jory Burson (JBR), Shu-yu Guo (SYG), Joe Sepi (JSI), Justin Ridgewell (JRL), Rob Palmer (RPR), Henry Zhu (HZU), Daniel Rosenwasser (DRR), Nicol√≤ Ribaudo (NR), Caio Lima (CLA), Valerie Young (VYG), Logan Smyth (LSH), Alan Schmitt (AS), Pedram Emrouznejad (PED), Sergey Rubanov (SRV), Nicolo Ribaudo (NRO), Guy Bedford (GBD), Ben Coe (BCE), Amal Hussein (AHN), Julien Gilli (JGI), , Sven Sauleau (SSU), Jack Steinberg (JBS), Ross Kirsling (RKG)</p>
<p>Remote:
Brian Terlson (BT), Ron Buckton (RBN), Jordan Harband (JHD), Leo Balter (LBR), Frank Yung-Fong Tang (FTG), Mike Samuel (MSL), Shane Carr (SFC)</p>
<hr>
<a href="#agenda"><h1 id="agenda">Agenda</h1></a><ul>
<li><a href="https://github.com/tc39/agendas/blob/master/2019/06.md">Agenda</a></li>
</ul>
<a href="#7-report-from-the-ecma-secretariat"><h2 id="7-report-from-the-ecma-secretariat">7. Report from the ECMA Secretariat</h2></a><ul>
<li><a href="https://github.com/tc39/Reflector/files/3232735/tc39-2019-026.pdf">Presentation</a></li>
</ul>
<p>IS: Page 3, total downloads, everything highlighted in red related to TC39.</p>
<p>IS: Opt out period as a last chance for companies to opt out from the ES-2019 Specs including their own IPs, that they do not want to see as part of the specification. This is required by the IPR policy, but in practice it has no practical relevance for TC39, as the JS language is not patent sensitive.</p>
<p>IS: For ES-2020 we will freeze specification again next year to give similar opt out period.</p>
<p>IS: This opt-out procedure has to be done before releasing any final version.</p>
<p>IS: On ES-2019 we can still make small editorial changes until the last minute but at some point TC39 Chairs need to notify the Ecma Secretariat which is the final version that we should officiall publish as ES-2019 standard.</p>
<p>IS: Thank you for very hard work from editors to have made this possible. Great job.</p>
<p>IS: Still some issues with PDF version. Not solved. By the way, US department of defense has asked us to send final copies of 2019 version, what we did. Would be nice to fix PDF version at some point in time that we do not send out printed versions that look not the best.</p>
<p>IS: These copies end up in the National Library and Ministries, etc.</p>
<p>IS: Would like to ask for help  to summarize what is new in this new version. PR is important.</p>
<p>IS: Need material for the Ecma News Press Release on what happened in Berlin, links, youtube videos</p>
<p>IS: if you see some problems with new website please let us know. This is coming up sometimes around this summer(?).</p>
<p>IS: Need to find a way to present the ES-Discuss archive from 2006-2019, not really readable in current state. But at least we have received the zipped archived files from Allen Wirfs-Brock.</p>
<p>IS: historical archive has shown to be useful in the past, important to have it in a readable way. Not only for history reasons but also because similar idaes tend to come up periodically, so it is useful to see, what reaction there was in earlier cycles.</p>
<p>IS: Patrick Luthi is going to be my successor as SG starting August 1. Will find a place and time for them to talk to folks. The Secretariat of TC39 has to be settled too, but no worry.</p>
<p>IS: Currently we're in an overlapping state, transitioning the role of SG until July 31 .</p>
<p>IS: ExeCom gave green light to 2019 version during its latest meeting.</p>
<p>IS: We have a conference calll as part of the Ecma GA on the future direction of Ecma. Zoom conferencing system in place for the June 27 2019 meeting so anyone can attend - who is interested in the topic.</p>
<p>IS: Our style in Ecma is from the 60s, it can be out of date now in 2019. We agreed that from now on we'll use first and last name, instead of gendered honorifics. Will leave it to each TC to decide specific usage of honorifics in minutes.</p>
<p>IS: Everyone interested in participating in GA is welcome to participate.</p>
<p>IS: Still have the possibility to contribute to fellow award for December 2019. Probably out of time for the June one.</p>
<p>IS: We have recommended Dan Ehrenberg for the June award, plus one more person from TC39.</p>
<a href="#8-reports-from-project-editors"><h2 id="8-reports-from-project-editors">8. Reports from Project Editors</h2></a><p>---- Put the notes in the order that we end up discussing things ---</p>
<a href="#8ii-ecma-402-internationalization-status-updates"><h3 id="8ii-ecma-402-internationalization-status-updates">8.ii ECMA-402 (Internationalization) Status Updates</h3></a><p>(Valerie Young)</p>
<ul>
<li><a href="https://docs.google.com/presentation/d/1rZrpQlgux4IoNvMXBHRb3l9uTvM4ff8wIxWD1H3SPwU/edit">Presentation</a></li>
</ul>
<p>VYG: For those who don't know, intl, e.g date object impl, etc.</p>
<p>VYG: Monthly 2 hour phone calls, can be joined, everybody welcome.</p>
<p>VYG: If you want to contribute look at todo column of project board.</p>
<p>VYG: Three editors, which is unusual. Me, Leo Balter and Isaac Durazo</p>
<p>VYG: Lots of action last month. Three of them being discussed at this meeting. First one waiting for impl but otherwise good to go (stage 3?).</p>
<p>VYG: New PRs from last couple weeks.</p>
<p>VYG: Stage 3 proposals</p>
<ul>
<li>Intl.relativeTimeFormat</li>
<li>Intl.locale</li>
<li>Intl.ListFormat</li>
<li>Unified Intl.NumberFormat</li>
<li>Intl.DateTimeFormat.prototype.formatRange
dateStyle/timeStyle more user friendly formatting of date/time string</li>
<li>Intl.Segmenter</li>
</ul>
<p>VYG: Stage 1 Proposals</p>
<p>DisplayNames</p>
<p>VYG: Real quick overview but you can look at slides and notes to learn more about those proposals.</p>
<p>VYG:  TC39 Task Group now we're formalized</p>
<p>VYG: Get involved, there's a git repo. Feel free to give feedback. If you speak any other language than English your feedback is super valuable!</p>
<a href="#8i-ecma-262-status-update"><h3 id="8i-ecma-262-status-update">8.i ECMA-262 Status Update</h3></a><p>(Jordan Harband)</p>
<p>JHD: 50 to 60 commits since 2019 finalized. Few normative ones especially around atomics. Strengthening the atomic model to provide better consistency.</p>
<p>JHD: Changes to string representation. Unicode updated for Unicode 12. We</p>
<p>JHD: Repository level things, Issue templates to try to have more helpful being filed.</p>
<p>JHD: Discourse link in README, things like that. ES2019 hasn't had any editorial changes pulled in; it's there in a branch. We're working on ES2020.</p>
<a href="#ecma-404-status-updates"><h3 id="ecma-404-status-updates">ECMA-404 Status Updates</h3></a><p>DE: No update for 404.</p>
<a href="#test262-status-updates"><h3 id="test262-status-updates">Test262 Status Updates</h3></a><p>(Caio Lima)</p>
<ul>
<li><a href="https://docs.google.com/presentation/d/1fvJ0M4y-M8FD8Vep1sKBftumx_LkENSlwEU3yC3bOIc/edit">slides</a></li>
</ul>
<p>CLA: Newly added tests: strange edge cases related to using proxies etc.</p>
<p>CLA: Build infra improvements</p>
<p>CLA: Looking for people to help us because it's a ton of work to do. Check before contributing to know how the contribution process works. Thank you Leo for mentoring new contributors. I was one of them two years ago.</p>
<p>CLA: Check for stage 3 proposals because usually there are tests missing there. Very useful for implementers, because they use those tests to determine compliance.</p>
<a href="#housekeeping-from-aki"><h2 id="housekeeping-from-aki">Housekeeping from Aki</h2></a><p>AKI: Wanted to remind everybody of a new member get-together at 17:30 today</p>
<p>AKI: How it's going so far, what questions you have.</p>
<p>AKI: Have been working on draft schedule. Lots of us with lots to say. Disclaimer: it's a draft and it's going to change. Don't want to rely on specific time slot but useful to know what's coming up.</p>
<p>AKI: A note not from the chair group but from me. I convinced ecma to buy tc39.es. Unless objections, will be the new domain name for the site currently at tc39.github.io. Plan to be adding a subdomain for the discourse but not sure what it should be, feel free to send opinions my way if you have ideas or feelings.</p>
<p>IS: On the request of Aki Rose tc39.es and other names have been reserved as URL. These days they cost practically nothing (12 CHF per year). Generally, we want to have it owned by service provider in Switzerland, because that is more practical for Ecma. At the moment only &quot;tc39.es&quot; is reserved, but no real service and data is beyond that.... Stay tuned...we have to wok on that closely with the TC39 web portal folks.</p>
<p>YS: Let's discuss on the reflector and we can discuss which name we want to go with.</p>
<p>YS: Have statistics for website and wanted to show them to you. Unfiltered statistics. (Would be good to have link to website statistics presentation)</p>
<p>YS: Top 4 countries visitors coming from: China, US, Korea, Hungary, Germany</p>
<a href="#dynamic-import-for-stage-4"><h2 id="dynamic-import-for-stage-4">Dynamic import() for stage 4</h2></a><p>(Daniel Ehrenberg)</p>
<ul>
<li><a href="https://github.com/tc39/proposal-dynamic-import">proposal</a></li>
<li><a href="https://docs.google.com/presentation/d/1-z1ZqitVb5z8IZYJZfQXuaSZnpeeQ80Ki2-YWYv30o4/edit#slide=id.p">slides</a></li>
</ul>
<p>DE: Champion is domenic denicola, thank you Domenic!</p>
<p>DE: Widely used by JS ecosystem.</p>
<p>DE: we have a PR against main specification. Needs to be updated.</p>
<p>DE: At the last meeting, we talked about the Realms proposal and Mark looked into this.</p>
<p>MM: Discussed it at the SES (Secure EcmaScript) meeting, discussed whether there would be any problem and concluded we should move forward.</p>
<p>DE: are we ready for stage 4? (no objection, round of applause)</p>
<p>DE: What about import.meta? Does anyone want to champion it for stage 4?</p>
<p>MM: With this not having been on the agenda, didn't spend time looking at it. Let's not consider stage advancement.</p>
<p>DE: total agreement. Would be at a future meeting. If you and your group have time to examine this that would be helpful.</p>
<p>MBS: happy to take a look and see if we can have the time to take it there.</p>
<p>DE: Does anybody else have concerns or would be interested in contributing?</p>
<a href="#conclusionresolution-dynamic-import-for-stage-4"><h4 id="conclusionresolution-dynamic-import-for-stage-4">Conclusion/Resolution</h4></a><ul>
<li>Stage 4 acceptance</li>
</ul>
<a href="#let-all-early-errors-be-syntax-errors"><h2 id="let-all-early-errors-be-syntax-errors">Let all early errors be Syntax Errors</h2></a><p>(Ross Kirsling)</p>
<p><a href="https://github.com/tc39/ecma262/pull/1527">PR</a></p>
<p>RKG: I have a normative PR today that lets all early errors be SyntaxErrors.</p>
<p>RKG: Basically the spec currently says that if you have <code>0++</code> or <code>0 = 0</code>, that is an early ReferenceError and not a SyntaxError. V8 and Chakra have fully implemented this spec. SpiderMonkey has avoiding implementing part of this spec to ensure we have this conversation.</p>
<p>RKG: That was two years ago but I've decided to be the one to formally bring it up now.</p>
<p>RKG: Do we want to revisit prior decisions? Who really cares what the type of a parse error is? Becomes a concern if we're considering eval. If we execute <code>a++</code> or <code>0++</code>, both would return ReferenceError, but no way to know if code was actually executed.</p>
<p>RKG: Early ReferenceError is really limited to those two situations even if you consider that destructuring assignment could lead to similar issues. Haven't chosen to do that. Between these two things can't say spec is consistent.</p>
<p>RKG: We could introduce a new error type to replace early ReferenceError, but I'm proposing the simple solution which is to go back to having all early errors be SyntaxError.</p>
<p>RKG: Mostly reserving this time slot for any controversy that could arise.</p>
<p>RKG: That's all I have to say short of any concerns from the committee.</p>
<p>YS: Does anyone have any comments/questions? (none expressed)</p>
<p>KG: Since no one is saying anything, I want to say I do support this. Would be very happy to see this change.</p>
<p>YS: Do we have consensus on this?</p>
<p>MM: Any V8 folks?</p>
<p>DD: I remember that they said yes.</p>
<p>YS: Do we want to wait for anybody else to give feedback before we can say we have consensus?</p>
<p>MM: XS guys, any comment on this?</p>
<p>RKG: It's wonderful how actually non-controversial this has been.</p>
<p>YS: Any comment from the Apple team?</p>
<p>MS: We're good with this change!</p>
<a href="#conclusionresolution-let-all-early-errors-be-syntax-errors"><h4 id="conclusionresolution-let-all-early-errors-be-syntax-errors">Conclusion/Resolution</h4></a><ul>
<li>Consensus reached</li>
</ul>
<a href="#for-in-enumeration-order-for-stage-2"><h2 id="for-in-enumeration-order-for-stage-2">For-in enumeration order for Stage 2</h2></a><p>(Kevin Gibbons)</p>
<ul>
<li><a href="https://github.com/tc39-transfer/for-in-exploration/">proposal</a></li>
<li><a href="https://docs.google.com/presentation/d/1Erd-E-73MPjr2kBBSYwK998SQ6roheiOqF2zprKgROo/edit">slides</a></li>
</ul>
<p>KG: Recap: not specified. That annoys me deeply. Several reasons: 1) thing that folks would like to rely on. 2) Actually you can rely on it. Have to put it into your engine if you want to be able to run code in the wild. Not a good situation.</p>
<p>KG: I have a proposal on GH. It has tests cases in there if you're interested.</p>
<p>KG: If you don't do anything weird, every engine agree. Hope to get consensus on some prose that describes the common case. Hoping to say &quot;in this case, you have to follow this order&quot;. Shouldn't require any engine to change anything. Maybe JavaScriptCore, not sure.</p>
<p>KG: I would like to get Stage 3 reviewers if we do get Stage 2.</p>
<p>KG: Have specified an iterator, whole purpose is to be referenced in normative prose which says: if neither <code>O</code> nor any object in its prototype chain is an exotic object, then the iterator must behave identically to it, until either O or an object in the prototype chain  has its <code>SetPrototypeOf</code>, <code>DefineOwnProperty</code> or <code>Delete</code> internal method invoked.</p>
<p>KG: Basically you can't have anything weird happen unless one of these is called during iteration.</p>
<p>KG: All I have to say, how does anyone feel about this?</p>
<p>MM: from the title of this I was really hoping that you'd propose a fully deterministic spec.</p>
<p>LG: been done, every iteration of that has been shut down, so I'm not trying. Got to start small. (laughs from group)</p>
<p>MM: This is a step forward.</p>
<p>DE: Can you summarize technical argument against fully specifying it?</p>
<p>KG: implementers are not all willing to make changes to make implementation align with each other and the spec.</p>
<p>KG: Without asking specifically every engine implementers I don't know but from past initiatives I'm not hopeful.</p>
<p>DE: (missed question)</p>
<p>KG: Do you look up complete prototype chain before iterating, do you check getOwnPropertyDescriptor before iteration or during. Is there a bit stored on the object that tells what kind of object it is that defines different ways to iterate, etc.?</p>
<p>DE: Concretely, about the inherited property case, my understanding is that was an interop issue but I don't understand how that is covered by your proposed changes</p>
<p>KG: the case where there's disagreement is that JSC will print out a property present on object with enumerable flag set to false and also set on its prototype chain with enumerable set to true.</p>
<p>DE: So, how does this get that?</p>
<p>KG: This does not get that. My hope is to make one small change that [can be agreed on].</p>
<p>DE: Wondering for implementations when there's this &quot;exotic object&quot; case</p>
<p>MM: The exotics are confusing.</p>
<p>MM: For/in causes a particular trap. Proceeding to use the result of that trap should not be a cause for non-determinism.</p>
<p>KG: It's more than just that trap: you have to check getOwnPropertyDesscriptor to see if the enumerable bit is set, have to call getPrototypeOf at some point, etc</p>
<p>KG: had originally hoped to just completely specify behavior for proxies. Still don't think it's a terrible idea. Seemed to be harder to convince people that it's worth specifying.</p>
<p>KG: One implementation expressed concerned having different path for proxies and non-proxies.</p>
<p>MM: altogether step forward and does not preclude further steps towards determinism later.</p>
<p>KG: Anyone has any thoughts about specifying behaviour for Proxies?</p>
<p>DE: proposal as is seems like a very good incremental step.</p>
<p>DD: Agreement for all impls except for JSC?</p>
<p>KM: Have to look at the bug again. Assuming change in semantics if you have a non-enumerable property shadowing an enumerable one then it isn't output.</p>
<p>KG: That's correct.</p>
<p>KM: doesn't seem like it's going to be a huge implementation problem for us but I guess we'll find out.</p>
<p>KG: Bug number is <a href="http://bugs.webkit.org/show_bug.cgi?id=38970">38970</a>.</p>
<p>YS: Got consensus for Stage 2</p>
<p>KG: Would like to ask reviewers for stage 3.</p>
<p>KG: I will ask WH</p>
<p>YS: I'd like to shadow a review.</p>
<a href="#conclusionresolution-for-in-enumeration-order-for-stage-2"><h4 id="conclusionresolution-for-in-enumeration-order-for-stage-2">Conclusion/Resolution</h4></a><ul>
<li>Consensus for Stage 2</li>
<li>POK &amp; NLT are reviewing together as Stripe</li>
<li>looking to ask WH and potentially other for the required additional reviewers</li>
</ul>
<a href="#bigint-to-stage-4"><h2 id="bigint-to-stage-4">BigInt to Stage 4</h2></a><p>(Caio Lima)</p>
<ul>
<li><a href="https://github.com/tc39/ecma262/pull/1515">proposal</a></li>
<li><a href="https://docs.google.com/presentation/d/1khTyfcbahlzYghSLcnlhsnK3EH16oLWpP11PE64SKtU/edit">slides</a></li>
</ul>
<p>CLA: idea is to provide a new literal and new kind of (missed) where they can create bigint values. Changes semantics arithmetic operators to allow them to use BigInt value types.</p>
<p>CLA: Introducing two new TypedArrays and new constructors for BigInt() and Number()</p>
<p>CLA: important to have that because no implicit conversion between bigint and numbers.</p>
<p>CLA: Very useful for scientific applications and geometric computations. Main interface to manipulate 64 bits integers to avoid precision loss. Today can implement those computations using strings if you don't mind precision loss and [missed other].
CLA: Also enables high-resolution timestamps.</p>
<p>CLA: cryptography is not an application. No guarantee that operation is going to take the same amount of time for different operands so vulnerable to side-channel attacks.</p>
<p>CLA: Not supporting bigint for unary + to not break asm.js, which uses unary + for a typecast. Decided to throw typeerror in this specific case.</p>
<p>CLA: Follow same approach of number/string addition for bigint/number addition, so we don't throw for that.</p>
<p>CLA: We can compare BigInts and Numbers using &lt;, &gt;, ==</p>
<p>CLA: We can access 64bit TypedArrays with BigInt. Set the value of a position using a bigint, and can retrieve the value also as a bigint.</p>
<p>CLA: Consider last 64 bits of bigint that is &gt; max 64 bits value.</p>
<p>CLA: bigint interacting with all parts of JS, so need to talk about JSON. Decided to not change semantics. Approach right now is to throw an error.</p>
<p>CLA: Implementations: chrome shipped bigint a year ago. Firefox 68 shipping next July I hope. No plan yet to ship in Safari (WIP). Node.js already supports BigInt (since V8 already supports BigInt).</p>
<p>CLA: PRs to introduce tests for BigInt. We're already covering pretty much the entire spec.
Thank you everyone being involved in that.</p>
<p>CLA: PR against main specification is ready. Pretty much ready to merge in the spec.</p>
<p>CLA: Any problems to move to Stage 4?</p>
<p>MM: you listed a bunch of implementations but you didn't list XS. I assume it is supporting it? (&quot;yes&quot; from XS) I suggest that in the future you include XS in the survey.</p>
<a href="#conclusionresolution-bigint-to-stage-4"><h4 id="conclusionresolution-bigint-to-stage-4">Conclusion/Resolution</h4></a><ul>
<li>Stage 4 acceptance (pending editor signoff on PR)</li>
</ul>
<a href="#evalnonstring-should-not-side-effect"><h2 id="evalnonstring-should-not-side-effect">eval(nonString) should not side effect</h2></a><p>(Mike Samuel)</p>
<ul>
<li><a href="https://github.com/tc39/ecma262/pull/1504">PR</a></li>
<li><a href="???">slides (missing link)</a></li>
</ul>
<p>MS: PR that modifies the spec to bring it to consistency with what most browsers should do.</p>
<p>MS: the issue is 1495 notes that there is inconsistency. PR 1504 brings it in.</p>
<p>MS: Web platform tests currently behind experimental flag which would pass once this gets cleared up.</p>
<p>MS: Problem in a nutshell: relates to how the hosts call out to (missed)</p>
<p>MS: At the top you can see that there's content-security header.</p>
<p>MS: The way the spec is written an eval of a non-string value does not actually trigger the host callout. Evan of string takes different path than eval of non-string. Probably a specification bug.</p>
<p>MS: Browsers differs on how this happens. Chrome and Safari allow it, FF is actually currently spec compliant and rejects it.</p>
<p>MS: Went over a couple of possible ways to fix this. The one on the PR: simplify things. Two places in the spec text where eval called. (missed) and then there's indirect eval which only has access to global scope.</p>
<p>MS: Changes the performeval callout to take (missed) so that it can call the post-environment. Today we fix both uses of PerformEval. We figured out a way to make it slightly cleaner. The PR is the authoritative one, but this is the gist of it.</p>
<p>MS: If everybody agrees we can go and fix this, but I would love feedback.</p>
<p>MM: very suspicious about both realms as being listed as parameters of both functions. Seems to come from a misguided attempt by spec to reuse same internal mechanism (PerformEval) for both direct and indirect eval.</p>
<p>MM: Direct eval is special form that executes in the lexical scope of the code containing the direct eval. Just like other special forms, like &quot;if&quot;.</p>
<p>MM: Indirect eval is just a function call, and the realm from which it's called should have no effect whatsoever.</p>
<p>MM: Wanted thoughts on splitting those cases and each case having only the relevant realm as parameter.</p>
<p>MS: Compatibility concern here. Spec that says: we reject if there's any CSP policy. Would be backward compatibility break.</p>
<p>MS: (missed details)</p>
<p>MM: I have a very concrete suggestion, that will not create operational difference. Simply include the direct flag as another argument to HostEnsureCanCompileStrings.</p>
<p>MS: my mistake that I put the slides this way. My apologies for confusion. I believe the GitHub diff, let me go ahead and see if GH diff could resolve any confusion I created.</p>
<p>MS: (showing GH diff).</p>
<p>MS: you can see the change to PerformEval. Does PerformEval with the appropriate realm. I see a comment. And yes that (missed) should be there.</p>
<p>MS: changing the name from evalRealm to consistently be called callerRealm.</p>
<p>MM: HostEnsureCanCompileStrings still has only two parameters. Suggesting that the host cannot do a (missed) job (missed). Suggesting we add a third parameter to pass through the direct flag.</p>
<p>DD: realm is a completely different issue. (missed). That should be pursued as a separate proposal.</p>
<p>MM: Not suggesting that CSP should be changed, suggesting that a flag be added. Then at least the host has enough information that it could make a sensible decision, even though the browser is already committed to not doing so.</p>
<p>MS: later in this session I will be floating a proposal that provides more context to the host callout. Domenic is right that this is a need-consensus so the scope is very narrow for this specific topic.</p>
<p>MS: do we have consensus?</p>
<p>YS: do we have consensus from the room? (thumbs up) Anything from anyone remote? )</p>
<p>(silence)</p>
<p>YS: Sounds good as in silence.</p>
<a href="#conclusionresolution-evalnonstring-should-not-side-effect"><h4 id="conclusionresolution-evalnonstring-should-not-side-effect">Conclusion/Resolution</h4></a><ul>
<li>We have consensus on this.</li>
</ul>
<a href="#atomicswaitasync-asking-for-stage-3-reviewers"><h2 id="atomicswaitasync-asking-for-stage-3-reviewers">Atomics.waitAsync asking for stage 3 reviewers</h2></a><p>(Shu-yu Guo)</p>
<ul>
<li><a href="https://tc39.github.io/proposal-atomics-wait-async/">proposal</a></li>
<li><a href="https://docs.google.com/presentation/d/1L6cBV_r6RBA_n3NPeab9hSx86QVy3-DPeXg4Dy3yDx0/edit">slides</a></li>
</ul>
<p>SG: async version of Atomics.wait. Was presented maybe a year ago but dropped the ball on updating it.</p>
<p>SG: Atomics.wait loosely modeled on futexes in linux kernel. Semantics roughly that it checks at time of calling if value at index of typedarray if value is what you're telling it.</p>
<p>SG: This is the blocking version</p>
<p>SG: Currently no async equivalent. Proposal is to add async equivalent with instead of blocking thread is to return a Promise.</p>
<p>SG: This was all presented before. Does this all make sense? (silence of assent)</p>
<p>SG: Resolution of cross agent promises done by HostResolveAgent</p>
<p>SG: There is a cross-agent promises list.</p>
<p>MM: I'm not understanding why is this a host hook? There's nothing about the mechanism that should differ between platforms?</p>
<p>SG: Isn't there a difference between hosts when you choose to queue the tasks to resolve the other promise(s)?</p>
<p>DE: There's a bit of complexity here, one of the other agents maybe IDL. The ideas that there's a certain run/event loop that each agent has, which are host-defined. The way it works in HTML if you need to wake an agent you need to queue a task.</p>
<p>SG: The take home is this is an embedder issue and shouldn't affect the semantics.</p>
<p>DE: Note, there will be a discussion about HostResolveAgent later, its role, how implementors will work with it.</p>
<p>SG: Main miss for stage 2 that (missed) identified last time. Semantics for waitAsync that promises are resolved in FIFO order, except if agent is already blocked. Motivation is if agent is blocked then resolving does nothing because agent is blocked.</p>
<p>SG: Semantics now proposed is that there's a queue of queues. All of the waits are on the same value and same typed array.</p>
<p>SG: Idea is that we have an agent-cluster-wide queue and a per agent queue of promises.</p>
<p>SG: Final argument of notify is how many waiting agents to wake up. It goes in FIFO order.</p>
<p>SG: This way everything is in FIFO order, there is no way for an agent to jump the cluster queue and starve another agent.</p>
<p>KM: Is this a strict requirement to have this (this ordering)?</p>
<p>SG: it is planned to be the required ordering at this point.</p>
<p>KM: my general experience and understanding having talked to people who are experts in blocks is that requiring super strict ordering tends to result in much slower in the micro contention case. In the end you'd have a situation where you require (missed). Maybe it doesn't matter because performance difference between this and C code might be sufficiently large that queuing time doesn't matter. Usually you want to spin-lock, adaptive lock. You may want to implement this lock as an adaptive spin.</p>
<p>SG: Still contained fairness, but a different kind of fairness?</p>
<p>KM: I guess, you can have other type of fairness. Instead of FIFO order, within n people who get queued, if someone is spinning, someone may bypass the queue. There is some arbitrary metric monotonically increasing that you will acquire.</p>
<p>SG: I'm definitely sympathetic to that, so far by ordering and no starvation is fair for me.</p>
<p>KM: This is the usual definition that I would use for fairness. The one here is the standard one that you can see in CS class on systems.</p>
<p>KM: We can talk about it offline.</p>
<p>SG: I'm not asking for stage 3 I'm asking for reviewers.</p>
<p>KM: I can offer commentary on the fairness thing.</p>
<p>KM: Actually I can review it.</p>
<a href="#conclusionresolution-atomicswaitasync-asking-for-stage-3-reviewers"><h4 id="conclusionresolution-atomicswaitasync-asking-for-stage-3-reviewers">Conclusion/Resolution</h4></a><ul>
<li>Reviewers:
<ul>
<li>Daniel Ehrenberg</li>
<li>Keith Miller</li>
<li>Rick Waldron</li>
</ul></li>
</ul>
<a href="#annex-b-reform"><h2 id="annex-b-reform">Annex B reform</h2></a><p>(Mark S. Miller)</p>
<ul>
<li><a href="?">slides (missing link)</a></li>
</ul>
<p>MM: got this section in the spec that has sort of been functioning as a dumping ground for things we need to codify for things are not part of the main spec.</p>
<p>MM: With the exception of XS, all of JS engines are primarily targeted to browsers. Outside the browser is everything is normative but optional</p>
<p>MM: What I always took &quot;normative but optional&quot; to mean is that you don't have to implement each element, but if you do implement it you must do so as specified. Somebody else took it to refer to Annex B as a whole, that is, you must implement Annex B as a whole or not at all.</p>
<p>MM: This was one of these cases we arrive at consensus on words because we didn't realize that we had not arrived at consensus on meaning.</p>
<p>MM: In the last paragraph (of the Annex B intro) uses &quot;normative&quot; in the natural language sense of normative: &quot;a recommendation&quot;. &quot;Programmers should not assume the existence of these features when writing new code. Implementers are discouraged from implementing these features unless the implementation is a part of a web browser or is required within a web browser.&quot; (quoted from Annex B intro)</p>
<p>MM: I think that is a very nice set of distinctions to have in the last paragraph that we actually discourage those features to be used or implemented when they're actually not part of the language.</p>
<p>MM: I want to use this Venn diagram to highlight the different categories. Including both strict and sloppy.</p>
<p>MM: Let's divide Annex B into two portions: safe and unsafe. Safe = <code>string.prototype.bold</code>, a little utility that makes HTML text out of data. Unsafe = <code>regex.$1</code> which is a global communications channel that simply reflects data from whatever the most recent match is of a regex instance in that realm against some string.</p>
<p>MM: There's stuff that's just perfectly safe from a non-locality, causality perspective. From this Venn diagram I'm going to make some recommendations on which things are going to stay in Annex B, and which things we're going to recommend bringing in the main spec.</p>
<p>MM: discouraging code is basically impossible; we can't prevent implementers from implementing optional parts of the spec, and we can't discourage programmers from using implemented APIs.</p>
<p>MM: This is an inventory of the elements of Annex B. Let's start with things that apply to both strict and sloppy code.</p>
<p>MM: Escape and unescape I believe are universally implemented, correct me if I'm wrong. (Nods from XS)  <code>__proto__</code> I was surprised to find both the <strong>proto</strong> access property and the {<strong>proto</strong>: ...} syntax in Annex B. Having variable syntax where some systems parse according to Annex B, and other systems parse not according to Annex B, where the same program text can have different meaning is a disaster. In a system not recognizing {<strong>proto</strong>: ...} as special syntax, it would instead evaluate to an object with a plain own property named &quot;<strong>proto</strong>&quot; with no effect on the inheritance chain.</p>
<p>MM: The <code>__proto__</code> access property and the {<strong>proto</strong>: ...} are in fact universal, and should be made mandatory.</p>
<p>MM: <code>__defineGetter__</code>, <code>__defineSetter__</code>, <code>__lookupGetter__</code>, and <code>__lookupSetter__</code> are all universal. Their specified semantics is simple, and they are easily implemented in terms of defineProperty. However, some current platforms provide buggy implementations of these, that leak the global &quot;this&quot; value.</p>
<p>MM: This is an example of why codifying it in a more mandatory fashion would make it less likely for these bugs to go unnoticed for so long. They would have been more rigorously tested.</p>
<p>MM: String.prototype additional methods there are substr, which is essentially another way to say slice. There's a whole bunch of HTML things including blink. And there's trimLeft and trimRight. If someone wants to argue that blink specifically remain optional, I would not resist. But the rest should be made mandatory.</p>
<p>MM: On date there is getYear and setYear, both of which are 2 digits year if I recall, causing Y2K fear. They're universal. Likewise toGMTString.</p>
<p>MM: Regex.prototype.compile is an odd beast. Last time I looked at it it seemed it violated the semantics of Object.freeze, but I haven't looked at that in a long time. Anyway, perfectly happy to let that stay in Annex B. It should not be mandatory.</p>
<p>MM: As with all optional properties, by leaving RegExp.prototype.compile optional, you enable a conforming implementation to omit it. By making it deletable, you enable a startup shim, in an environment where it is present, to delete it, producing a state that is still a conforming initial state.</p>
<p>MM: The upcoming Error stack proposal codifies Error.prototype,stack as optional, in Annex B, while introducing getStack and getStackString as virtualizable globals that are mandatory.</p>
<p>MM: Document.all is a horror that exists for one particular purpose, and shouldn't be implemented anywhere else. For people who don't know what these oddball cases are, in a way that's the point for things who remain in Annex B and be as optional as possible.</p>
<p>MM: The <code>for (var x = y in ...)</code> is completely meaningless and useless but it is accepted, I am not sure if it is sloppy-only.</p>
<p>KG: It is!</p>
<p>MM:  In that case I'm much happier. I read the text about var declaration inside catch blocks but I couldn't understand.</p>
<p>KG: Catch parameters are lexical declarations, and normally you can't have a lexical declaration that conflicts with an existing var declaration, but <code>var e</code> inside of a <code>catch (e) {</code> predates let syntax. So <code>try {} catch (e) { var e; }</code> was legal in ES5 and it has to remain legal in ES6.</p>
<p>MM: The var thing I'm very happy that's sloppy only, I'll move it in the (missed) section. My bias on syntax is to mandate syntax because however horrible the syntax is, having the syntax parse programs differently is a worse horror.</p>
<p>MM: Annex B also has mandated several pieces of syntax that are already specific to sloppy mode. To my mind quarantining them to sloppy mode is adequate. They don't need to be doubly quarantined by also being in Annex B. Any code that's avoiding sloppy mode and any environment that enforces the absence of sloppy mode already avoid these cases.</p>
<p>MM: There's these things that we never codified that are part of JS: .caller, .callee, .arguments Anyone who implements sloppy mode should implement those.</p>
<p>MM: Now I want to bring attention to the greatest horror of them all, which is html-like comments. Everybody that has taken part in building an accurate JS parser, raise your hands. For all those people I'd like you to keep your hands down for next question. For rest of you, who believe that they understand correctly how html-like comments are parsed? OK 1 person (Aki, because Leo Balter had explained) !</p>
<p>MM: HTML-like comments, they are not specific to sloppy. Distinction between program code and module code. Module code does not recognize them. Fact that this parses as html comment somewhere and does not parse as html like comment elsewhere means that you can write the same code that means different things depending on context.</p>
<p>MM: Somebody found a complete attack against Caja, because the Acorn parser that Caja used to look at the code first, before passing it on to the platform, misunderstood the rules to parse things that looked like HTML-like comments.</p>
<p>MM: Having these things in Annex B makes it that much worse. Even if you know things are being parsed by an accurate Script parser (not module parser), since it's in Annex B, you don't know whether it's been parsed recognizing html-like comments or not. Parser-based tools --- transpilers, linters, syntax highlighters, IDEs, don't know how to parse accurately if they don't know whether the target platform implements this optional parsing rule.</p>
<p>MM: My recommendation is that HTML-like comments be promoted to the main spec. Even though they're horrible and I'd like to kill them, having them be recognized somewhere and not elsewhere is worse than having them recognized consistently everywhere.</p>
<p>KM: Can you clarify what you mean by mandate?</p>
<p>MM: What I mean by mandate is by moving it into the spec and removing the text that mentions it's optional to implement it.</p>
<p>KG: You said recognized everywhere, even for modules?</p>
<p>MM: The current spec mandates that modules not recognize html-like comments. I made not recommending that modules do recognize them. But I have a very distasteful recommendation for modules which can stand separately. What I would recommend for modules is that if those string occurs in code for modules, that it's a static error.</p>
<p>KG: Even in a comment?</p>
<p>MM: Everywhere they would have been recognized as html-like comment in code it's better to have them as static error because people move code between script and modules. In order to avoid a program silently meaning different things either for accidental or malicious purposes, I think it's better to have modules reject that code. Our tools, including transpilers, do not switch their recognition of html-like comments depending on whether the code is supposed to be script or module code. Thus, the only safe things for modules to do is to reject these.</p>
<p>(MM realizes post meeting: Even better is to continue to leave a normative choice in the spec, but a different one: html-like comments should always be detected, but they can either be accepted according to the html-like comment rule, or they can be statically rejected. This would allow any parser-based to statically reject, while still conforming to both the script and module grammars.)</p>
<p>MM: No concrete proposal today, just wanted to raise this and have that discussion so that we can reduce the size of Annex B so that introductory paragraph can maintain its force.</p>
<p>KM: Do we know if standard minifiers are aware if they're emitting code in module or not?</p>
<p>MM: What I know is minifiers all have a mechanism that prevents them from emitting an apparent html-like comment string as a result of rendering an operator tree.</p>
<p>KM:  I can totally imagine that <code>--&gt;</code> can be emitted from (missed) places.</p>
<p>MM: Any further comment?</p>
<p>AVK: Main thing I want to say is that it is overdue, at least from browser and html embedding side, having it separate is bad.</p>
<p>TST: Would you say that there is there more it might be okay for the main spec to (missed) mark as optional?</p>
<p>MM: We need to distinguish two motivations for making things optional. Making things optional in general,  one mandatory for all browsers. I understand why people implementing browsers need spec of what is mandatory for browsers. Those two things can be decoupled, where those two things end up when they're decoupled doesn't necessarily matters.</p>
<p>TST: I agree, but obviously one of these is different from the other (missed)</p>
<p>MM: WeakRef.prototype.constructor doesn't yet exist. Error.prototype.stack, and sloppy .caller, .callee, and .arguments exist de facto but not yet de jure.</p>
<p>MM: Moving things from Annex B to the main spec explicitly marked normatively optional, I don't have any problem with that.</p>
<p>DE: Moving more things into the main spec sems really good. Editorially having them out of line has been confusing a lot of people as you pointed out. Is there still a thing that we want to call normatively optional? If so we keep it inline. In HTML spec (missed) these are very useful because when you read the spec you don't need to skip as many things. I know an engineer who's trying to implement JS compatible regexps (missed). We should as much as possible put all the text inline, and if we want to add some metadata about it, then this would be very good editorially. Does anyone have any concern about this?</p>
<p>DD: In the absence of concrete proposal we should not add to Annex B - moratorium on Annex B.</p>
<p>MBS: Does anyone object on moratorium on Annex B?</p>
<p>MM: We don't yet have consensus for what it means for something to remain in Annex B. I think I'm ok with what Domenic is suggesting but as long as we're willing to reconsider if a particular case comes up. If there's one thing for which we really want to put it in Annex B. With that provision we're willing to consider the odd case, then yes I'm for that.</p>
<p>LB: This presentation feels like a description of the problem. How do we follow up/what happens next? See this as a proposal, would co-champion this.</p>
<p>MM: I'm not volunteering to lead an effort to turn these things into PR or proposal. But if somebody is volunteering to lead that, I'm certainly ready to help with that.</p>
<p>DE: I think the next steps from here it makes sense to follow -up with issues on the main ecma repository about these two plans we can pursue incrementally with PRs. Moving some things from Annex B into main spec, and making sure that the rest of Annex B is inline normative optional. Lots of people who can contribute to these editorial patches if we can provide a direction. I can volunteer to document this potential plan.</p>
<p>TST: Fully agree, thank you</p>
<p>AVK: Are these needs-consensus PRs?</p>
<p>DE: If we get a bunch of PRs, we should get consensus on the package, since it's a big editorial change.</p>
<p>MM: Anything that is a significant restructuring of the spec, we'd still need consensus. I would want consensus on that.</p>
<p>SG: What you're proposing is to rethink where we draw the (missed) lines.</p>
<p>MM: I'm proposing everything on the left side of my diagram, they'd be made mandatory. They are universally implemented, and many programs already rely on those things without problems. Let's make those programs correct.</p>
<p>TST: Leo asked what the next steps are. Two things we can do today. One of those is do we have consensus on accepting changes to the spec that fold certain parts of Annex B into the main text? Don't want to be in the situation where someone does a lot of work to refactor this and at a meeting someone blocks those changes.</p>
<p>MM: Everything in the mandate boxes are normative changes not editorial.</p>
<p>DE: I would be in favor of these things to be mandatory, some of those may be problematic.</p>
<p>MBS: Are we good to move on to the next item? Thank you everyone.</p>
<p>DE: Can we agree that on this editorial plan of moving parts of Annex B to the main spec? And moving some things from normative optional to normative and I think we have consensus. I'm very happy about this result.</p>
<p>DE: We're really talking about a series of editorial changes.</p>
<p>LBR: Should we do this as a staged proposal in a separate repository?</p>
<p>DE: I think it'd be best to coordinate via a GitHub issue in ecma262. We can work with online contributors that way. I'll write this up, help coordinate, and do reviews.</p>
<a href="#conclusionresolution-annex-b-reform"><h4 id="conclusionresolution-annex-b-reform">Conclusion/Resolution</h4></a><ul>
<li>We have consensus to move several parts of Annex B into the main spec, not normative optional, including the items marked &quot;mandatory&quot; in Mark's presentation and everything about grammar (both HTML comments and RegExp syntax)</li>
<li>We have consensus to move remaining Annex B things inline, marked as normative optional there (similarly to what we have in Intl legacy constructor paths), modulo fixing up a11y issues that BT raised.</li>
<li>DE will file an issue to describe the concrete next steps, so that others can fan out and write up the changes.</li>
</ul>
<a href="#how-should-we-specify-jobs-precisely"><h2 id="how-should-we-specify-jobs-precisely">How should we specify Jobs precisely?</h2></a><p>(Daniel Ehrenberg)</p>
<ul>
<li><a href="https://github.com/tc39/???">proposal</a></li>
<li><a href="https://docs.google.com/presentation/d/1LLIIwZyQgm6rbAyWbRjFFSNKlA2DPqslpN8sVKjchjE/edit#slide=id.p">slides</a></li>
</ul>
<p>DE: Domenic made this PR a few years ago called layering which fixed the jS infrastructure. That's what I'd like to follow-up on today.</p>
<p>We were discussing this with the atomics, also going to come up with weak references. It's important that we have good spec (missed).</p>
<p>The JS spec uses these terms of jobs, runjobs, etc. A job is used in the spec when a promise is resolved and rejected there's a callback that is executed. In the browser this is called a microtask and we use this term in this committee as well.</p>
<p>In general JS has this run to completion concept.</p>
<p>DE: this is what makes promises run after synchronous code in a function. In HTML &amp; Node, Promise jobs run before the rest of the &quot;event loop&quot;.</p>
<p>DE: You can think as all these promise jobs as running in this synchronous (asynchronous?) section.</p>
<p>DE: In HTML and Node, the algorithm (simplified) is: run the JS code, run the Promise jobs, return to the event loop (which may call back into javascript, eg when network connection comes maybe call some event in js).</p>
<p>DE: This is a huge simplification, there are a lot of details.</p>
<p>MM: What was the simplification?</p>
<p>DE: It is an abstraction.</p>
<p>DE: The goal of this <em>proposal</em> is to let the job ordering be precisely specified, to ensure interoperability between implementations. We want to specify JS precisely, and thereby also precisely specify implementations which are supposed to be interoperable.</p>
<p>DE: In html there is the html event loop. There's proposal to change this such as the scheduling proposal from the chrome team. In node.js there's also (missed).</p>
<p>DE: Editorially in the spec we see these core algorithms enqueueJob and runJobs. Ordering and (missed) are implementation defined.</p>
<p>DE: This ends up so messy and strange and hard to hook into. HTML uses a willful violation of JS. Here's what it means when the JS specification calls enqueueJob. In some web/JS implementations the code does correspond to this. Other times they reusing some of the logic, but in general when trying to figure out how these things fit together, the (missed).</p>
<p>DE: Why does this matter? Several proposals touch the job queue: promises, WeakRefs, atomics.waitAsync, maybe more. I'm optimistic that in this committee we'll be expanding the JS library and adding more capabilities to the language.</p>
<p>DE: We'll run into more cases where we'll need to specify those things. Current mismatch is just confusing, the multiple job queues has been a source of confusion for people reading the spec and trying to figure out what's going on.</p>
<p>DE: DD's proposal was basically that we'd have this HostEnqueueJob operation that'd take queueName. Would always use the promises queue or something like that and it'd use this job structure, it would be [defined by the host? Missed details].</p>
<p>MM: You're saying the Javascript spec should specify what the hosts must follow?</p>
<p>DE: the PR includes set of self-contained example use cases.</p>
<p>DE: Really seems like it provides the exact same invariants as current specification.</p>
<p>DE: Alternative which was sort of based on help and discussion from Anne and Domenic was to have one-off (missed).</p>
<p>DE: In WeakRefs the current draft spec text uses this HostleanupFinalizationGroup. It's expected to queue up calls to CleanupFinalizationGroup. It doesn't use jobs. We could use similar organization for promises.</p>
<p>MM: just a clarification question: The CleanupFinalizationGroup doesn't use jobs (totally missed that)</p>
<p>DE: Sort of philosophical question on how we should editorially write that down. I believe run to completion is really important invariant for JS and it'd be important to work on wording for that.</p>
<p>DD: Really like the simplicity of the WeakRefs/Atomics approach</p>
<p>DE: I think it's personally what I would choose between the two.</p>
<p>DE: Point of this proposal is to allow us to precisely (missed).</p>
<p>DD: thank you Dan your work on this. Lots of opportunities if we go that direction which is simpler. I like that a lot.</p>
<p>TST: This would be cross spec refactoring that keeps the same behaviour across systems?</p>
<p>DE: yes exactly there would a bit, number of algorithms in spec that are dead spec text. Top-level module evaluation job that are abstract, tied in. The idea would be to clean this up and really stick to clear. Once we would remove those the only thing that would use the job queue right now would be promises.</p>
<p>TST: Is follow-up to tighten requirement on when jobqueue is (drained?). You can't use the full flexibility in what we have right now in all implementations because you can't serve multiple job queues in arbitrary order.</p>
<p>DE: Reading Allen's comments, has a clear explanations on (missing)</p>
<p>DD: I looked into the implementation they were doing, and it was to drain the jobs queue, then do the function call, which was a really roundabout to do it. So, just, don't do that.</p>
<p>MM: I think I don't understand the point that is being made wrt weakreafs and atomics. They schedule this callback to the finalizer that happens later. What does it mean to call it or not call it a job. And what does it mean. I'm just confused.</p>
<p>DE: Short answer: it doesn't mean anything. There's basically 3 points in time: jobs correspond to what HTML calls &quot;microtasks&quot;, which are drains at particular points. Then weakref finalization happens after microtasks are drained‚Äî (interrupted)</p>
<p>MM: The JS microtasks are there's multiple microtasks queues spec doesn't say how many there are. Not advocating we stay with current, don't understand the point made for weakrefs and atomics.</p>
<p>MM: Is the weakrefs finalization and anything else and therefore must it happen before (missed)</p>
<p>Would happen after all of promises, rationale is that</p>
<p>DE: There may be other I/O that would be queued on the event loop.</p>
<p>MM: Certainly possible for there to not be a queue, but it's possible that nothing could happen if there's a queue.</p>
<p>DE: I think you're taking the inverse and conflating it with the initial thing. One situation is that we need to call the (missed) when the engine is idle. This sort of structure is how browser, you can't wake up the engine by adding a promise job. It runs at a lower priority.</p>
<p>MM: Trying to understand wrt what's being said about weakrefs as an example. From what was presented early, would have assumed that all promises run to completion first, then all I/O tasks happen when there are no queued promise things.</p>
<p>AVK: What engines intend to implement is promise queue is drained, then weakrefs happen, then (missed).</p>
<p>MM: Asking about weakrefs vs I/O events.</p>
<p>DD: Weakrefs also need to enqueue something. I don't think we need to nail-down something like layering in order to make that work.</p>
<p>DE: There's nothing inherent about the ordering there.</p>
<p>MM: Not trying to argue about weakrefs here, just using weakrefs as example of something and trying to understand what that something is an example of.</p>
<p>DE: It's an example of when we need the host to be involved in scheduling something. There are times (like waking from sleep) that require the host's input for scheduling. Happy to go into details.</p>
<p>MM: OK I think I'm not asking about HTML, asking about the meaning of what you're proposing as (missed). Let's take it offline. I'm confused, not objecting to anything.</p>
<p>DE: Can we try to come back to this on Thursday? I would like to come to a conclusion, it's been on for years.</p>
<p>DD: Anyone else have any issues?</p>
<p>KM: do we have anything for Test262 in terms of having specific ordering somewhere?</p>
<p>DE: Just editorial change so nothing we can test about it.</p>
<p>KM: For the sake of testing what the freedom of what the JavaScript language specifies... for like webplatform tests.</p>
<p>DE: I don't know what exactly we should put in Test262 and what we should put in web-platform-tests. We could put weakrefs and how they interact.</p>
<p>AVK: To some extent it's an ongoing problem with workers and other things and how they should be tested.</p>
<a href="#conclusionresolution-how-should-we-specify-jobs-precisely"><h4 id="conclusionresolution-how-should-we-specify-jobs-precisely">Conclusion/Resolution</h4></a><ul>
<li>DE to follow up with MM, who's in favor of the overall direction, just wants to clear up confusion.</li>
<li>No other concerns raised</li>
</ul>
<a href="#set-name-property-for-anonymous-functions"><h2 id="set-name-property-for-anonymous-functions">Set &quot;name&quot; property for anonymous functions</h2></a><p>(Sathya Gunasekaran)</p>
<ul>
<li><a href="https://github.com/tc39/ecma262/pull/1490">proposal</a></li>
<li><a href="https://docs.google.com/presentation/d/1G-i0HpZaH6xkJPuJTJ2yUoI6Qk28Fe837aeOjT_-HsM/">slides</a></li>
</ul>
<p>SGN: Small update on setting own name property on anonymous functions.</p>
<p>SGN: Little background: ES2015 says There should be no name property on anonymous functions.</p>
<p>SGN: This wasn't well-motivated. Not a performance thing or anything. No overhead for engines to do it. The name getter is lazily created.</p>
<p>KM: Probably.</p>
<p>SGN: Current status (cf slide) v8 &amp; spidermonkey agree on almost everything (wrt anon functions/classes/generators/etc), whereas Chakra implements it per spec, and there is a bug and they don't have async generators.</p>
<p>MM: What does &quot;cycle&quot; mean?</p>
<p>SGN: JHD wrote a test for the various browsers, and it just ran infinitely in a cycle.</p>
<p>There's a bit of back and forth on GH issue already, conclusion of that discussion is that you would add own name property of anonymous functions. It is possible given that Safari does it. PR by Andre bargull with all of this specified and needs reviews, assuming there's consensus here. Any questions?</p>
<p>MBS: Doesn't look like we have any question, is there something on the queue?</p>
<p>KM: What's the actual change left?</p>
<p>SGN: We added one <code>name</code> property to anonymous functions.</p>
<p>TST: We're all failing a bunch of tests because we are not spec compliant (and this proposal would make the spec match the implementations). We moved this because we'd need a flag that (missed).</p>
<p>SGN: Would be great if we could come to a conclusion here.</p>
<p>DE: very in favor of this change. I apologize for not reviewing this PR. This is probably good editorially.</p>
<p>What we could try to accomplish here, is if we could get consensus on the semantics, then we can get Test262 to get these tests passing again.</p>
<p>SGN: That's exactly what I'd like to do. Once the reviews are done can we merge it?</p>
<p>LBR: I'm +1 with this change and I'm interested in writing the tests for this. The skip list we have in V8 will be helpful to flag the tests necessary to update on Test262.</p>
<a href="#conclusionsresolutions-set-name-property-for-anonymous-functions"><h4 id="conclusionsresolutions-set-name-property-for-anonymous-functions">Conclusions/Resolutions</h4></a><ul>
<li>We have consensus on the semantics of the change to add an own &quot;name&quot; property to anon functions and classes (if web compatible)</li>
<li>We need more folks to review it.</li>
<li>We're waiting on reviews and tests to merge it.</li>
</ul>
<a href="#trusted-types"><h2 id="trusted-types">Trusted types</h2></a><p>Mike Samuel (MSL)</p>
<ul>
<li><a href="https://wicg.github.io/trusted-types/dist/spec">proposal</a></li>
<li><a href="https://docs.google.com/presentation/d/e/2PACX-1vQCbxmHKjPWUq7MC91x6tJKanFYU2i9Z13wwfkngcseHt96EfU_xyA0awkxb4SoNW3hQ3S2z-ByX0T9/pub?start=false&amp;loop=false&amp;delayms=60000">slides</a></li>
</ul>
<p>MSL: An explanation to provide context for this stage 0 proposal that I hope to put before everybody tomorrow or the day after.</p>
<p>MSL: Trusted types is a WICG proposal that affects JS APIs</p>
<p>MSL: I work in google security engineering group, For the past six years we've been trying different things. Trusted types is an attempt to bake Google's internal strategies for combating XSS into the browser.</p>
<p>MSL: When security researcher find an XSS security issue they report it to us. That's what those stats show. [see slides]</p>
<p>MSL: Very happy with these techniques. Proposing to bake these into the browser.</p>
<p>MSL: Reason it is timely because biggest trending security bug is DOM XSS. Happens when a developer lets an attacker control stream reach an (missed) API.</p>
<p>MSL: Problem is twofold: easy to introduce, easy to give an attacker string access to DOM APIs, and really hard to detect.</p>
<p>MSL: As client-side web frameworks become more popular dom xss is increasing. Neither static analysis or human reasoning are doing a good job of mitigating that.</p>
<p>MSL They they work you can opt in by a header, CSP</p>
<p>MSL: Does require changes to the way you do things. Promise of trusted type is it's going to guard DOM sinks.
Guards DOM sinks (like .innerHTML).</p>
<p>MSL: You can't assign any string with html, but you can with Trusted Types [see slides]</p>
<p>MSL: Decision to trust can be very far away from the side-effect. Once the trust decision is made, that trusted value can be used later in a DOM sink.</p>
<p>MSL: What this means is that we as a security team can focus our attention on verifying small amount of code that can affect the results of those policy objects.</p>
<p>MSL: No effect on semantics, Big organizational effect. Think about why teams of good developers produce bad code.</p>
<p>(MSL reading comics in slides deck)</p>
<p>MSL: &quot;Not clear to me how my individual contribution will have clear impact on security, so I'll focus on adding new features&quot;.</p>
<p>MSL: Goal is to overcome the inability for a rational actor to balance security with new features.</p>
<p>MSL: Makes a third party more effective. When a dev can reasonably assume that security can't be broken by any other dev, they can prioritize well.</p>
<p>[MSL showing code sample from slides of how to create policies]</p>
<p>MSL: Once trusted types have been turned on in dev, you get errors in the dev console about using unsafe strings for DOM.</p>
<p>MSL: Because system fails closed, it's one more bug to fix but it's a visible one.</p>
<p>MSL: When they go and talk to their peers they have something to show. No single developer has to be responsible for those security issues now that those policies make those problems visible.</p>
<p>MSL: Implemented in Chrome. Believe Firefox people are playing around with it. Got some spec text still being worked on. Love feedback on issues tracker and discussion group.</p>
<p>MSL: As I said before, I'll be presenting couple stage 0 proposals that enable some of the work we're doing. Questions?</p>
<p>MM: Trusted type function should verify, not coerce, argument. Rather than <code>String(arg)</code> more like <code>if (!(typeof arg === 'string')) throw ...</code>. The hazard with coercing is that the caller may inadvertently be holding something something that coerces to different strings at different times. This wouldn't violate the trusted types guarantees themselves, but it might mislead callers into assuming safety properties they don't have.</p>
<p>MM: First of all would like to endorse your citation of jim morris' paper, Protection in Programming Languages. I like the overall direction. Question on a detail in your presentation. Can you go back to slide with significant amount of code? You're using &quot;String&quot; to coerce x to a string. For this type of security code it'd be better to verify rather than coerce. The caller might reason that if the result of passing x to this is good, then x has some kind of good attribute. If x simply coerce to a String that was good this time, doesn't mean it'll coerce to a String that is good next time.</p>
<p>MSL: That string is unnecessary. Risk of polymorphic objects.</p>
<p>MSL: Even if dev on a deadline decides to replace globalThis.String I think it'd still fail closed. But agree this is a risk.</p>
<p>YS: Other questions or comments?</p>
<p>DRR: You have TS support as well? Are you statically verifying that or are you doing runtime checks?</p>
<p>MSL: TS and Google's closure compiler both have unsound type systems. We're not actually relying on the type system for this. Reason why we believe DOM XSS is biggest security threat because reliance on unsound type linters for client-side JS we're not checking trustedness everywhere we should be.</p>
<p>[missed additional question]</p>
<p>Linters and static type analysis will be helpful to support devs to migrate applications' code. It's an explicit goal to not rely on static analysis for security. Instead we bake dynamic enforcement into the browser.</p>
<a href="#conclusionresolution-trusted-types"><h4 id="conclusionresolution-trusted-types">Conclusion/Resolution</h4></a><ul>
<li>No conclusion, this presentation is just for TC39's information. MSL will be submitting Stage 0 soon.</li>
</ul>
<a href="#javascript-standard-library-for-stage-2"><h2 id="javascript-standard-library-for-stage-2">JavaScript Standard Library for Stage 2</h2></a><p>(Michael Saboff)</p>
<ul>
<li><a href="https://github.com/tc39/proposal-javascript-standard-library">proposal</a></li>
<li><a href="https://github.com/tc39/proposal-javascript-standard-library/blob/master/slides/JSL-TC39-June-2019.pdf">slides</a></li>
</ul>
<p>MS: We have a lot of topics to discuss. Including some contentious ones. [Agenda from slides].</p>
<p>MS: Proposing built-in modules shipped with the engine. This proposal is about the mechanism to do that, not about the content of the built-in modules themselves. Some confusion about this in previous rev of this proposal.</p>
<p>T Namespaces: talking about how to identify what we import as it pertains to domains of the technology that is in a particular library.</p>
<p>T: Contentious topic: Do we have one unified namespace that everything pulls from, or separate namespaces?</p>
<p>T: (Referring to slides) Follow same exact syntax that exists for importing modules. Proposing that module specifier has a prefix.</p>
<p>(see slides for example)</p>
<p>T: &quot;js:&quot; prefix specifies that it's a JS core module that you're importing.</p>
<p>(continues presenting slides about &quot;Why module domains?&quot;)</p>
<p>DD: Wanted to point out a lot of interest from non-browser environments, like CloudFlare and Node.js for kv-storage.</p>
<p>MM: Other environments like Node.js, which have a kv-storage, what should be the main prefix there we should work out. There's also the option of a Node-specific prefix.</p>
<p>(MM points out to next slide about domain specific prefixes)</p>
<p>MM: Don't think we're the ones who should define what those prefixes are. All three of these worlds would be able to access the language specific items. I know there's different viewpoints on this after talking to different implementers, we're looking for questions and comments on this..</p>
<p>NTE: I don't understand the motivation for a standard library.</p>
<p>MM: we assumed that everyone understood the motivation for standard library. Global object has issues. The first problem is memory and startup time to start an engine.</p>
<p>MM: The second problem is the pollution issue, a lot of stuff in there, for example Proxy, probably you're not using that in your current application.</p>
<p>MM: The third problem is that programmers can clearly define what they want with standard library import.</p>
<p>MM: Standard way that people add functionality is they change that global object and there can be danger in that when two modules want to do that and there's collision. And often that's discovered late in the process.</p>
<p>MM: Is that sufficient to answer your question?</p>
<p>NTE: Yes.</p>
<p>AHN: How does this retroactively affect what's in the global namespace?</p>
<p>MS: Short answer, It wont,</p>
<p>AHN: Shouldn't?</p>
<p>(missed answer)</p>
<p>AHN: How is namespacing preserved as well, things like import * as, etc. Curious what the namespacing story and collision semantics are.</p>
<p>MS: Same as for modules. Want to give a clean environment for developers.</p>
<p>MS: We're trying to avoid this big global object while not breaking the web.</p>
<p>AKI: now that we're done with clarifications let's move on to strong opinions.</p>
<p>TCN: Lots of IoT stuff for node. Fetch example of something in the web but not in/for node. These things are not necessarily mutually exclusive. What is the path forward to making sure these things are shared instead of separated. E.g. node could potentially implement IoT.</p>
<p>MS: We're creating a world that requires more or different coordination than we have now. If creating array like object I own anything that is on that prototype. Here we have to have coordination. Makes sense you bring up IoT and node. Makes sense you wouldn't have IoT or other domains specific to just one type of host. You can think that some of the browser's tech will be shared with node. But calling it javascript is not the right thing. Still need some coordination that exists. Those groups interested in IoT would need to coordinate. We're not offering mechanism for that coordination. High order in my mind for having separate domains if for the programmer. Programmer understands I want to use x, it's part of JS, I should be able to find it in the js: namespace.</p>
<p>??: There is something distinct about tc53 is doing, it is a very different runtime model. The APIs we're designing you may not want to use them in node. I don't think the goal of the work of tc53 is to be universally useful.</p>
<p>MM: would you agree that it'd be useful for you to have a specific domain?</p>
<p>??: Absolutely.</p>
<p>MS: I can see that tc39 js:, but also intl: as a separate domain because it's distinct functionality that is clear.</p>
<p>MBS: looking at is and i'm conflicted, as I would not take node <code>fs</code> to put in js: or web:, on the other hand today the web: is URL, urlencode/decode, would be weird to attach these to js: namespace. Question becomes how do we define that? It just seems confusing to me.</p>
<p>MS: Biggest JS module providers need to come up with what coordination is needed. Point I'm trying to make is I believe programmer has better mental model if we do have separate domains than if we have a single on. Example of using &quot;map&quot; as a name that can mean different things in different namespaces. E.g. js' map and css' map. I don't know what coordination looks like.</p>
<p>MBS: absolutely make sense for the namespace mechanism. Would be good to clarify from the get go is that the intention is not for TC39 to be owner of the js: namespace.</p>
<p>MS: we have to allow for that, it can't be this is my playground you can't come in. [missed details on MDN example].</p>
<p>MS: agree that MDN good place to start documenting this.</p>
<p>GB: not sure about ambiguity on web apis and Node.js. In case of examples we mentioned like fetch, Node.js implementation is not compatible with web one. Could fallback from one to the other.</p>
<p>MS. Yes and if you have web:worker and js:worker importer needs to know the difference.</p>
<p>BCE: Forcing sharing can be good. Some exciting stuff in node is that we've been integrating Inspector from chrome, as an example. Other thing is worst case scenario is you have a nodejs URL and a web URL.</p>
<p>MS: or tools namespace</p>
<p>DE: I think I actually wanted to say the opposite. True some APIs are analogous like web workers, other APIs are trying to be compatible, including with tests.</p>
<p>MS:: we don't want to bifurcate or a flea market of different implementations of the same thing, it's going to require coordination.</p>
<p>DD: Reasonable, but concerned about moving into common modules, for example storage?</p>
<p>MS: only thing is underlying tech of indexdb. Workers and indexdb are not part of JavaScript. Think of tc53 like watch does it make sense to convey to a developer that they can use a js:kv-storage in an environment where they can't.</p>
<p>DD: Don't think web developers have a mental model of what is JS. Some people think setTimeout is in the JS spec. Some JS impls don't implement portions of the spec like Intl.</p>
<p>MS: this goes back to the thing we handwave right now: how do you coordinate those domains.</p>
<p>DD: Google's perspective is that js and the web share one namespace.</p>
<p>MS: why is it fine to have node have separate namespace and not other?</p>
<p>DD: It's up to the hosts to express that. Node.js should express that if that's what they want.</p>
<p>MS: As part of an implementer of a web team I disagree with that.</p>
<p>DD: It can be more convenient for us to make developers choose whether the web team or the JS team wrote the functionality. But they should not need to; they just use the available APIs.</p>
<p>MS: It's not who put it in there, it's what it does.</p>
<p>MS: namespace should convey to the user what technology is in a module and where they can use it. I'm talking from a core language perspective, not TC39 perspective.</p>
<p>DD: Expressing that need of coordination is required</p>
<p>DE: really like the idea of coordinating. One thing we could start with is a GH repository where we can cross reference to different proposals about shared namespace. We could put the different things we're thinking about for the shared namespace. It's easy to point out some of the issues but things are improving over time. Other standards are becoming more open and more collaborative.</p>
<p>MS: we have to have an online repo of what's in what namespace.</p>
<p>DE: started a list like that a while a go but (missed). Believe it's going to be more subtle than &quot;other environments&quot; or &quot;it's not core JS&quot;. Non-tc39 things that are in other envs. Sometimes JS environment that it's really hard to deny it's a JS env. E.g cloud flare workers, yes it's not compliant but it can run a lot of programs. We can use this shared namespace extensively.</p>
<p>MS: trying to understand the point you're trying to make.</p>
<p>DE: just an example how complicated (missed). Overall it seems that we're sort of in agreement that we'd have a namespace like not everything is specified only by TC39 and we need coordination.</p>
<p>MS: Need to figure out what goes in what namespace. We have no idea how JS will be used, so no clues what those domains or namespaces will be. Need to be able to evolve, add more prefix.</p>
<p>MS: we have no idea of JS is going to be used in the future. Don't want to preclude that we have a list of what those domains are going to be. We have to be able to evolve and add more prefixes and domains.</p>
<p>DE: would be pretty skeptical of intl as a separate namespace. Not that big, it seems a bit weird. If we put intl in separate namespace then we get to 6 different namespaces.</p>
<p>DD: when trying to evaluate this proposal it seems we need to figure this out before this can move to stage 2.</p>
<p>MS: I do believe its required to have discussions with other stakeholders.</p>
<p>AHN: It seems like it's going to be a (missed) model. Who's really responsible ? Is this the browser, the engine, etc.? Also curious why these specific namespaces? That mental model is not immediately obvious to everyone why there are certain things that can only be e.g. in node runtime.</p>
<p>MS: totally agree with the first thing you talked about. Is our current spec structure the right place to document where things belong. Yes we need new governance model for that and disseminate information. As far as examples, those are just examples. Only thing is that I think we should have a &quot;js&quot; namespace. It's the only one that from my point of view I can feel confident about. Does that answer your question?</p>
<p>AHN: Yes.</p>
<p>MM: Concerned about what you meant, for example &quot;the js: shared across web standards bodies&quot;. We must be guardians of what is the language. If we create new namespaces that other people have governance over, then we abdicate governance over our language.</p>
<p>MS: I generally agree with you, I think we can delegate some of that process but ultimately for core language we need to be involved and say yes. I think that other standard bodies could propose some new library that would be part of the core language and follow our process.</p>
<p>MS: It could be another technical subcommittee.</p>
<p>MM: That's fine.</p>
<p>MS: That's explicitly why I want multiple namespaces, so we don't just have Global Object all over again. Do agree with governance model, it could be very different from what it is right now. Is the process the same? It could be a sub-committee or a (missed).</p>
<p>AKI: Do we agree that this needs a governance approach?</p>
<p>DD: Want to point out that we coordinated really well on the shared namespace with other standard bodies. I think we should continue to coordinate. Mark's concern about us being the 'guardians of JS' is why I think &quot;js:&quot; is a bad namespace for us to coordinate in together; the basic namespace should not be something we feel a need to guard, but instead something we collaborate in.</p>
<p>AKI: let's talk polyfills.</p>
<p>(moving to next slide: Module Loading)</p>
<p>Currently one operation that host provides to load modules. Proposing a chain loader where (missed, maybe built-in loader?) would register its module loader. Slightly more generic option than what is strictly necessary. Partly based on what other languages do things like Java and Python. Would like to look at other proposals like import maps to see if they'd be compatible.</p>
<p>We add a polyfill where we think incompatibilities are problematic‚Äîmissing modules, incomplete implementations, or changing behavior. Import maps could be a good polyfill solution to be provided by a host.</p>
<p>MHK: Some alternatives that were suggested that we should be aware of. [moving to &quot;alternatives&quot; slide].</p>
<p>MS: Import maps answers all those different scenarios</p>
<p>MHK: Pipe symbol alternative proposal. [referring to ModuleSpecifier fallbacks slide].</p>
<p>MHK: Special do block (referring to import statement callback slide)</p>
<p>MHK: Final option is doing this at runtime [referring to Runtime Hooks slide]. Very flexible but security considerations. We can expand this API such that it becomes more and more complex. Can also do things like intercept crypto module and load something that does insecure things.</p>
<p>JHD: what language-mandated mechanism will exist for altering specifier meaning? Node currently doesn't have import maps. JS engine could exist with the current proposal that doesn't implement those hooks. Allowing host to <em>optionally</em> provide the requirements for me does not meet the requirements. What if a host doesn't provide one of those mechanisms? Is import maps required to be implemented in some form by this proposal?</p>
<p>MHK: Polyfilling means something different for every host.</p>
<p>JHD: When I think of polyfilling I think of adding/removing/changing functionality, but [missed rest of question]</p>
<p>MS: (referring to loading chain slide) Two steps process here. Blue is resolve, red is load. Process continues until you run out of loaders. Implementations can decide how and if they want to resolve a module.</p>
<p>KM: What about host environments? If the desire to replace things as a host-delegated action, I believe that should be at the host level, not at every lower-level of the web page.</p>
<p>AKI: it's 5pm, we're going to have to continue this at a later time.</p>

</body>