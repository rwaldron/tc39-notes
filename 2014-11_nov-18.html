<!doctype html>
<meta charset="utf-8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.6.0/github-markdown.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/javascript.min.js"></script>

<title>November 18, 2014 Meeting Notes</title>
<body class="markdown-body">
<a href="#november-18-2014-meeting-notes"><h1 id="november-18-2014-meeting-notes">November 18, 2014 Meeting Notes</h1></a><hr>
<p>Brian Terlson (BT), Taylor Woll (TW), Jordan Harband (JHD), Allen Wirfs-Brock (AWB), John Neumann (JN), Rick Waldron (RW), Eric Ferraiuolo (EF), Jeff Morrison (JM), Sebastian Markbåge (SM), Erik Arvidsson (EA), Peter Jensen (PJ), Eric Toth (ET), Yehuda Katz (YK), Dave Herman (DH), Brendan Eich (BE), Ben Newman (BN), Forrest Norvell (FN), Waldemar Horwat (WH), Alan Schmitt (AS), Michael Ficarra (MF), Jafar Husain (JH), Lee Byron (LB), Dmitry Lomov (DL), Arnaud Le Hors (ALH), Chip Morningstar (CM), Caridy Patiño (CP), Domenic Denicola (DD), Mark S. Miller (MM)</p>
<hr>
<a href="#welcome"><h2 id="welcome">Welcome</h2></a><p>JN: Introduction</p>
<ul>
<li>Approval of 42nd Meeting Notes?
<ul>
<li>Approved</li>
</ul></li>
<li>Adoption of Agenda?
<ul>
<li>Approved</li>
</ul></li>
</ul>
<a href="#41-es6-draft-status-update"><h1 id="41-es6-draft-status-update">4.1 ES6 Draft Status Update</h1></a><p>(Allen Wirfs-Brock)</p>
<p><a href="./es6-status-update.pdf">es6-status-update.pdf</a></p>
<p>AWB: One revision since last meeting, rev 28.</p>
<ul>
<li><p><a href="http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts#october_14_2014_draft_rev_28">http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts#october_14_2014_draft_rev_28</a></p></li>
<li><p>Modules</p></li>
<li><p>Removed loader pipeline and Reflect.Loader API (moved to a new document)</p></li>
<li><p>Stream lined module linking semantics for declarative modules</p></li>
<li><p>Removed module declaration</p></li>
<li><p>Updated import decl. to include module imports</p></li>
<li><p>Updated defautl export syntax and semantics to support export of anonymous default functions</p></li>
<li><p>Added Module Env Records
(See slides)</p></li>
<li><p>There's a bug in rev r28 wrt module name normalization – should be relative to current module, was omitted (included in r29)</p></li>
<li><p>Interim Subclass instantiation reform
(Copy from slides)</p></li>
<li><p>Changed ordinary object creation to dispatch object allocation through [[CreateAction]] internal slot instead of @@create</p></li>
<li><p>Converted all @@create methods into [[CreateAction]] abstract operations</p></li>
<li><p>Eliminated Symbol.create and @@create</p></li>
<li><p>super without an immediately following
(Copy from slides)</p></li>
</ul>
<p>WH: What was the conclusion, not clear from the notes</p>
<p>AWB: (revisits problem statement and agreed upon solution)</p>
<ul>
<li><a href="https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-24.md#object-instantiation-redo">https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-24.md#object-instantiation-redo</a></li>
<li><a href="https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-24.md#conclusionresolution">https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-24.md#conclusionresolution</a></li>
</ul>
<p>EA: What about argument passing?</p>
<p>BT/RW: This was concretely included in conclusion</p>
<p>AWB: (Confirms)</p>
<ul>
<li>Rev28 Draft</li>
<li>ES6 eval semantics</li>
<li>Eliminated unused abstract operations PromiseAll PromiseCatch, PromiseThen</li>
<li>Modified Promise.all to specification internally uses a List instead of an Array</li>
<li>Added @@iterator property to %IteratorPrototype%</li>
<li>Added requirement that the object returned by ordinary object [[Enumerate]] must inherit from %IteratorPrototype%</li>
<li>Removed @@iterator from various standard iterators (inherited now)</li>
<li>Updated ToPropertyKey to accept Symbol wrapper objects, similar to how other priitive coercion abstract operations handler wrapper objects</li>
<li>ToNumber now recognizes binary and octal integers</li>
<li>Significant fix to destructuring assignent where the rest aassingment target is itself a destructuring pattern.</li>
<li>Updated Annex A Grammars to match ES6</li>
</ul>
<p>AWB: (whiteboard)
Now allowed:</p>
<pre><code class="language-js">[a[<span class="hljs-number">1</span>], ...[f, ...rest]] = array;
</code></pre>
<a href="#42-end-game-planning"><h2 id="42-end-game-planning">4.2 End Game Planning</h2></a><p>(Allen Wirfs-Brock)</p>
<ul>
<li>Needed:</li>
<li>One paragraph summary of ES6 goals for introduction</li>
<li>Clause 4 - Language Overview. Needs to reflect ES6 features</li>
<li>Readers, reviewers</li>
<li>Ecma-402 2nd Edition, review</li>
<li>How will we resolve last minute issues?</li>
</ul>
<p>DH: questions about March deadline, JN says deadling is important for patent issues, AWB says that last-minute changes could push publication date</p>
<p>DH: worst-case scenario: possibility of shipping a broken of ES6 to preserve the release momentum, getting the finished spec to the GA</p>
<p>WH: we can't ship a broken ES6</p>
<p>DH: respectfully disagree, need to get a quality ES6 out into the world, that momentum is very important to see</p>
<p>AWB: zero expectation that the ES6 spec is going to be perfect: &quot;too much like software to have any expectations&quot;</p>
<p>AWB: will open a bug tracker on bugs to deal with early errata, hit the next edition – turnaround in a year!</p>
<p>DH: if we do find issues, they won't be hanging out in the world as long</p>
<p>AWB: Revisiting confidence in current state of spec.</p>
<ul>
<li>Keep in mind next opt-out period: <a href="https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-07/jul-30.md#rftg-admin-es6-opt-out-period">https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-07/jul-30.md#rftg-admin-es6-opt-out-period</a></li>
</ul>
<p>DH: If time before we ship, could we do more? Realms? Probably not. Consider revisiting try/finally restriction on generators?</p>
<p>BE: We didn't end up on that path.</p>
<p>AWB: Need to review iterator algorithms for any places that have abnormal exits to call <code>return()</code></p>
<p>RW: (explanation of why the language overview draft is incomplete)</p>
<ul>
<li>Can we get a concrete due date?</li>
</ul>
<p>AWB: Before the holidays</p>
<p>RW: (agreement)</p>
<p>AWB: 402 2nd Edition</p>
<p>RW: Currently updated to reflect the necessary changes for ES6. Allen and I have decided to coordinate 402 edition publication with 262 editions (eg Ecma-262 6th -&gt; Ecma-402 2nd, and so forth)</p>
<p>TODO: Review with Allen</p>
<p>AWB: What to do about last minute changes?</p>
<p>BE: es-discuss, but not everyone reads this all the time.</p>
<p>AWB: Can we use the reflector to start conversations?</p>
<p>DH: We need to be prepared to have conference calls</p>
<a href="#43-assignment-to-a-const-static-error"><h2 id="43-assignment-to-a-const-static-error">4.3 Assignment to a const: static error?</h2></a><p>(Allen Wirfs-Brock)</p>
<p><a href="https://esdiscuss.org/topic/throwing-errors-on-mutating-immutable-bindings">https://esdiscuss.org/topic/throwing-errors-on-mutating-immutable-bindings</a>
<a href="https://bugs.ecmascript.org/show_bug.cgi?id=3253">https://bugs.ecmascript.org/show_bug.cgi?id=3253</a></p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> x = <span class="hljs-number">42</span>;
x = <span class="hljs-number">32</span>; <span class="hljs-comment">// early error?</span>
</code></pre>
<ul>
<li>es-discuss consensus: eliminate early error, because analysis during parsing is hard and no clear consensus that's work the parser should be taking on</li>
<li>current spec. draft (legacy) ES5 semantics only throws on assignment to an immutable binding in strict mode:</li>
</ul>
<pre><code class="language-js"><span class="hljs-string">"don't use strict"</span>;  <span class="hljs-comment">// ?</span>

<span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">"globalReadOnly"</span>, { <span class="hljs-attr">value</span>: <span class="hljs-string">"readonly"</span> });

<span class="hljs-keyword">var</span> func = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// silently skips assignment</span>
  f = <span class="hljs-literal">undefined</span>;
  <span class="hljs-comment">// silently skips assignment</span>
  <span class="hljs-literal">undefined</span> = <span class="hljs-number">42</span>;
  <span class="hljs-literal">Infinity</span> = <span class="hljs-number">0</span>;  
};
func(); <span class="hljs-comment">// no exception thrown</span>
</code></pre>
<ul>
<li>Should assingment to const also be silent in non-strict mode? Exception will require some new spec mechanisms.</li>
</ul>
<p>WH: Leery about introducing new kinds of state that then make their way into various reflection APIs. This extra bit of state to distinguish const bindings from merely immutable ones will not be reflected to user code in any way, right?</p>
<p>AWB: Right.</p>
<a href="#conclusionresolution-43-assignment-to-a-const-static-error"><h4 id="conclusionresolution-43-assignment-to-a-const-static-error">Conclusion/Resolution</h4></a><ul>
<li>Runtime assignment to const bindings (ie. bindings introduced by the const keyword) throw in all modes (strict and non-strict).</li>
<li>Legacy const bindings (function name binding in function expressions) in sloppy mode continue to be no ops</li>
</ul>
<a href="#44-arrayprototypecontains-breaks-mootools"><h2 id="44-arrayprototypecontains-breaks-mootools">4.4 Array.prototype.contains breaks MooTools</h2></a><p>(Allen Wirfs-Brock)</p>
<p><a href="https://esdiscuss.org/topic/having-a-non-enumerable-array-prototype-contains-may-not-be-web-compatible">https://esdiscuss.org/topic/having-a-non-enumerable-array-prototype-contains-may-not-be-web-compatible</a>
<a href="https://esdiscuss.org/topic/array-prototype-contains-solutions">https://esdiscuss.org/topic/array-prototype-contains-solutions</a></p>
<p>AWB: The issue is not &quot;contains&quot;, but specifically in how they create their mixins</p>
<p>(General discussion to clarify: String.prototype.contains, <code>Array.prototype.contains</code>. Both are problematic)</p>
<p>Tabling until Domenic arrives.</p>
<p>BT: Conflict in Outlook web version, <code>Array.prototype.values</code>. This has been patched and the issue should dissappear in the next few months.</p>
<ul>
<li>Where there is one problem, there are many...</li>
</ul>
<p>BE: Mark may have a proposal for fixing the <code>Array.prototype.contains</code> issue. If we're waiting for Domenic, can we wait for Mark? Is he coming?</p>
<p>AWB: We agreed to not worry about <code>Array.prototype.values</code>, because it can be fixed and the fix is quickly distributed.</p>
<p>BT: IE team has pushed forward on <code>Array.prototype.values</code> in the technical preview (small applause).</p>
<p>EA: We can roll it out again as well.</p>
<p>Discussion of alternative paths for <code>String|Array.prototype.contains</code>. Come back to it.</p>
<a href="#conclusionresolution-44-arrayprototypecontains-breaks-mootools"><h4 id="conclusionresolution-44-arrayprototypecontains-breaks-mootools">Conclusion/Resolution</h4></a><ul>
<li>Revisit with Domenic present</li>
</ul>
<a href="#45-global-let-shadowing-of-global-object-properties"><h2 id="45-global-let-shadowing-of-global-object-properties">4.5 Global let shadowing of global object properties</h2></a><p>(Allen Wirfs-Brock)</p>
<p>AWB: issues:</p>
<ul>
<li>When are/arent' global lets allowed to shadow an aleady existing property of the global object</li>
<li>Are buit-in global equivalent to global vars or are they just properties of global object</li>
<li>Make it illegal to shadow a global property would mean future global properties are breaking changes</li>
</ul>
<p>Proposal:
Runtime error when instantiating a script if a lexical declaration shadows a non-configurable property of global object.</p>
<p>WH: Any new non-configurable global properties would be a breaking change</p>
<p>DH:</p>
<p>AWB: Takes care of known issues, eg <code>let Infinity = ...</code></p>
<p>WH: What does it solve?</p>
<p>DH: w/o this fix: the hazard is that any code can change the meaning (in an irrevocable way) of a global</p>
<p>WH: If it shadows locally, then it's local to scope</p>
<p>DH: This is in top level, script</p>
<p>BE: This is an issue for JITs, when we made non-configurable, JITs took advantage of this</p>
<p>DL: Yes</p>
<p>WH: Can you retroactively introduce a let?</p>
<p>EA: Yes.</p>
<p>DH: Which footgun is least problwem?</p>
<p>AWB: BZ claims there are security implications.</p>
<p>DH: Jason couldn't provide any security issues</p>
<p>AWB/BE: In BZ's email</p>
<p>WH: contained in your scope?</p>
<p>DH: The lexical contour is global</p>
<p>BE: (from BZ's email): <code>window.location</code>
... we should just do it.</p>
<p>AWB: Short of redesigning the entire global lexical scope contour.</p>
<p>BE: <code>window.location</code>, etc. are &quot;own&quot;</p>
<p>DH: Any time you ask for it, it must always be that exact property. If it's on the prototype, the chain can be mutated.</p>
<p>AWB: Properties non-configurable, function declarations didn't override them. Issues in ES5.</p>
<p>DH/BE: Always global:</p>
<ul>
<li>window.location</li>
<li>window.top</li>
</ul>
<p>BE: The minimum solution is to address only own properties of the global.</p>
<p>DH: Based on the current state of the global object.</p>
<ul>
<li>Have to specify when the check is done.</li>
</ul>
<p>AWB: At var instantiation</p>
<p>DH: Mutated later to <em>become</em> non-configurable, unaffected. Does not retroactively become an error.</p>
<p>JHD: ? About built-ins configurability</p>
<p>DH: Non-issue, we won't specify which <em>names</em>.</p>
<ul>
<li>No retroactive error because (dave can you fill this in)</li>
</ul>
<p>WH: Why should they be allowed to make something non-configurable later?</p>
<p>BE/AWB: Just an object</p>
<p>BE: Might try to do a two way check? Not worth it.</p>
<p>WH: This will bite us at some point.</p>
<p>DH: Locking down environment against untrusted code, you've always had to be the first to run.</p>
<p>Clarification of who is setting up the invariants. User code vs. Browser.</p>
<p>BE: Browser wants to know later that when it makes access to <code>location</code> or <code>top</code> that it will get the binding that it created.</p>
<p>DH: The browser just has to lock it down before any other code. Just like user code that wants to lock down the environment.</p>
<p>WH: Why do this if security is an issue and not make them let bindings?</p>
<p>BE: Not backwards compatible</p>
<p>WH: Can't create new non-configurable properties</p>
<p>AWB: Anytime there are local scripts with top level var and let bindings, you have possible conflicts with other bindings. It just <em>is</em>. A good a reason to use modules.</p>
<a href="#conclusionresolution-45-global-let-shadowing-of-global-object-properties"><h4 id="conclusionresolution-45-global-let-shadowing-of-global-object-properties">Conclusion/Resolution</h4></a><ul>
<li>Error when instantiating a script if a lexical declaration shadows an own, non-configurable property of global object.</li>
</ul>
<a href="#46-zepto-broken-by-new-thisconstruct-usage-in-some-arrayprototype-methods"><h2 id="46-zepto-broken-by-new-thisconstruct-usage-in-some-arrayprototype-methods">4.6 Zepto broken by new this.construct usage in some Array.prototype methods</h2></a><p>(Allen Wirfs-Brock, Brian Terlson)</p>
<p>BT: The checks that Zepto does internally to know what to construct is broken by changes in Array methods.</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> obj = {};
<span class="hljs-keyword">var</span> obj.__proto__

</code></pre>
<p>The problem is that ES6 Array methods do not explicitly create new Arrays anymore, but instead call <code>this.constructor</code>. Zepto uses a plain object with <code>__proto__</code> assigned...</p>
<p>fill in later</p>
<p>AWB: Spec text that breaks Zepto:</p>
<pre><code><span class="hljs-number">4.</span> <span class="hljs-keyword">If</span> O <span class="hljs-keyword">is</span> an exotic Array <span class="hljs-built_in">object</span>, <span class="hljs-keyword">then</span>
   a. <span class="hljs-keyword">Let</span> C be <span class="hljs-keyword">Get</span>(O, <span class="hljs-string">"constructor"</span>).
   b. ReturnIfAbrupt(C).   
   c. <span class="hljs-keyword">If</span> IsConstructor(C) <span class="hljs-keyword">is</span> <span class="hljs-literal">true</span>, <span class="hljs-keyword">then</span>     
i.  <span class="hljs-keyword">Let</span> thisRealm be the running execution context’s Realm.     
ii.  <span class="hljs-keyword">If</span> SameValue(thisRealm, GetFunctionRealm(C)) <span class="hljs-keyword">is</span> <span class="hljs-literal">true</span>, <span class="hljs-keyword">then</span>     
iii. <span class="hljs-keyword">Let</span> A be the result <span class="hljs-keyword">of</span> calling the [[Construct]] internal method <span class="hljs-keyword">of</span> C <span class="hljs-keyword">with</span> argument (<span class="hljs-number">0</span>). 
<span class="hljs-number">5.</span> <span class="hljs-keyword">If</span> A <span class="hljs-keyword">is</span> undefined, <span class="hljs-keyword">then</span>   
a. <span class="hljs-keyword">Let</span> A be ArrayCreate(<span class="hljs-number">0</span>).
</code></pre>
<p>AWB: Forced me to revisit &quot;species&quot;.</p>
<p>Discussion clarifying the cause.</p>
<p>AWB: We can fix this by doing one more level of indirection...</p>
<p>Zepto Proposed Fix</p>
<pre><code><span class="hljs-number">4.</span> <span class="hljs-keyword">Let</span> C be <span class="hljs-keyword">Get</span>(O, <span class="hljs-string">"constructor"</span>)
<span class="hljs-number">5.</span> ReturnIfAbrupt(C)
<span class="hljs-number">6.</span> <span class="hljs-keyword">If</span> IsConstructor(C) <span class="hljs-keyword">is</span> <span class="hljs-literal">true</span>, <span class="hljs-keyword">then</span>
a. <span class="hljs-keyword">Let</span> thisRealm be the running execution context<span class="hljs-comment">'s Realm. </span>
b. <span class="hljs-keyword">If</span> SameValue(thisRealm, GetFunctionRealm(C)) <span class="hljs-keyword">is</span> <span class="hljs-literal">true</span>, <span class="hljs-keyword">then</span> 
i.   <span class="hljs-keyword">Let</span> species be <span class="hljs-keyword">Get</span>(C, @@species);
ii.  ReturnIfAbrupt(species)
iii. <span class="hljs-keyword">If</span> IsConstructor(species) <span class="hljs-keyword">is</span> <span class="hljs-literal">true</span>, <span class="hljs-keyword">then</span> 
<span class="hljs-number">1.</span> <span class="hljs-keyword">Let</span> A be the resu;t <span class="hljs-keyword">of</span> calling the [[Construct]] internal method <span class="hljs-keyword">of</span> species <span class="hljs-keyword">with</span> argument O. 
<span class="hljs-number">7.</span> <span class="hljs-keyword">If</span> A <span class="hljs-keyword">is</span> undefined, <span class="hljs-keyword">then</span>   
a. <span class="hljs-keyword">Let</span> A be ArrayCreate(<span class="hljs-number">0</span>).
</code></pre>
<p>WH: If @@species is intended to create copies of the current object, then why wouldn't Object.constructor have a @@species? Wanting to create copies of Objects is perfectly natural, but then we'd be back to the same Zepto problem. What you'd want is a @@speciesButDoNotDefineMeOnObjectConstructorUnderPentaltyOfBreakingZepto.</p>
<p>What color is the bikeshed?</p>
<ul>
<li>species</li>
<li>copyConstructor</li>
</ul>
<p>BT: Is this 100% back compatible?</p>
<p>AWB: It should be</p>
<p>Who is going to implement and test?</p>
<p>BE: put in spec.</p>
<p>Remaining differences...</p>
<p>AWB: ES5 always gave an array for these methods. For subclassing, we needed to change that.</p>
<p>DD: This works well for creating Promise subclasses.</p>
<ul>
<li>Promise and Array are only built-ins that have methods that make instances of themselves.</li>
<li>eg. <code>new this.constructor()</code></li>
</ul>
<a href="#conclusionresolution-46-zepto-broken-by-new-thisconstruct-usage-in-some-arrayprototype-methods"><h4 id="conclusionresolution-46-zepto-broken-by-new-thisconstruct-usage-in-some-arrayprototype-methods">Conclusion/Resolution</h4></a><ul>
<li>Allen's proposed fix accepted.</li>
<li>It's called &quot;species&quot;</li>
</ul>
<a href="#51--44-arrayprototypecontains-and-stringprototypecontains"><h2 id="51--44-arrayprototypecontains-and-stringprototypecontains">5.1 &amp; 4.4 Array.prototype.contains and String.prototype.contains</h2></a><p>(Domenic Denicola, Mark Miller)</p>
<p>DD/RW/BT: Just change them both to <code>includes</code>. It solves it directly.</p>
<p>DH: Consistency constraint? Any other ducktyping that expects &quot;contains&quot;?</p>
<p>Probably</p>
<p>DD: There are also DOM APIs that &quot;look like&quot; arrays, but have no Array.prototype methods, but <em>do</em> have a <code>contains</code> method.</p>
<p>RW: DOMTokenList (and one other?)</p>
<p>BE: This is a naming game</p>
<p>BT: Let's just do <code>includes</code></p>
<p>BE: (agrees)</p>
<p>MM: (explanation of analogous operations on Array to String.prototype.contains)</p>
<p>There is precedent for papering over the difference between substring and array elements</p>
<a href="#conclusionresolution-51--44-arrayprototypecontains-and-stringprototypecontains"><h4 id="conclusionresolution-51--44-arrayprototypecontains-and-stringprototypecontains">Conclusion/Resolution</h4></a><ul>
<li><code>String.prototype.contains</code> =&gt; <code>String.prototype.includes</code></li>
<li><code>Array.prototype.contains</code> =&gt; <code>Array.prototype.includes</code></li>
</ul>
<p>Continues...</p>
<p>DH: We should be allowed to extend built-in prototypes. New syntax can't be the first solution.</p>
<p>Discussion about how, when and where it's appropriate to publish polyfills that adhere to specification bound features.</p>
<p>SM: Not possible to publish polyfills and know that users will be responsible with upgrades</p>
<p>JHD: Each change with the spec has to be a major version bump.</p>
<p>BE: Need to know when to risk</p>
<p>JHD: An es7-shim will likely have finer granularity in feature detection.</p>
<p>DD: Tests will never be complete enough</p>
<p>MM: Experience in SES is proof that the things that need to be tested for will always grow.</p>
<p>DH: We should reprise this conversation when Yehuda is here, he has concrete recommendations to share with authors, with regard to train model.</p>
<p>AWB: Is there something that modules can help with? <code>import ...</code> and get ES7 features?</p>
<p>DD: No, that's effectively &quot;use es7&quot;;</p>
<p>AWB: Modules loaded for side effects?</p>
<p>MM: shouldn't encourage the pattern</p>
<a href="#48-template-literal-call-site-object-caching"><h2 id="48-template-literal-call-site-object-caching">4.8 Template literal call site object caching.</h2></a><p>(Erik Arvidsson, Mark Miller, Allen Wirfs-Brock)</p>
<ul>
<li><a href="https://bugs.ecmascript.org/show_bug.cgi?id=3305">https://bugs.ecmascript.org/show_bug.cgi?id=3305</a></li>
<li><a href="https://mail.mozilla.org/pipermail/es-discuss/2014-July/038343.html">https://mail.mozilla.org/pipermail/es-discuss/2014-July/038343.html</a></li>
</ul>
<p>AWB:</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> world = <span class="hljs-string">"world"</span>;
<span class="hljs-keyword">let</span> t = <span class="hljs-string">"tag`hello, ${world}`"</span>;
<span class="hljs-built_in">eval</span>(t);
<span class="hljs-built_in">eval</span>(t);

<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(t)();
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(t)();

tag<span class="hljs-string">`hello, <span class="hljs-subst">${world}</span>`</span>
</code></pre>
<p>How many unique callsites? 5, 3, 2 or 1?</p>
<p>AWB: Note that the following</p>
<pre><code class="language-js">tag<span class="hljs-string">`hello, <span class="hljs-subst">${world}</span>`</span>
tag<span class="hljs-string">`hello, <span class="hljs-subst">${world}</span>`</span>
</code></pre>
<p>has two unique callsites.</p>
<p>BE: Identity can be observed</p>
<p>MM: If you adopt the answer 1, there is no communication channel open. Although mutable state is reachable from the callsite (nee template) object, the only such mutable state is the primordials (Array.prototype, etc). Thus, the memo must be per-realm -- by contrast with the global Symbol registry. The identity sharing is surprising. If we want to avoid that surprise, then 5 is the answer. The performance argument says 1. Whatever the <code>tag</code> function pre-computes, it will typically memoize based on the identity of the callsite (nee template) argument. Note that ES6 provides identity-based maps, but provides no content-equality-based maps for use on array or object keys.</p>
<p>AWB: &quot;Callsite&quot; is probably the wrong term.</p>
<p>WH: What is <code>tag</code>? System or user code?</p>
<p>BE: Tag is not the thing that we're discussing being memoized. It's the constant array that's passed to tag.</p>
<p>MM: (restating issue) The object that captures the literal part of the expession that's captured for the call.</p>
<p>DH: If we go with 5, the argument becomes: regain performance that's been lost? Can the programmer do it for themselves?</p>
<ul>
<li>So if I want the function to execute multiple times, how can implement the single &quot;cached&quot;.</li>
<li>Impossible to get the performance of 1, because the 5 would <em>always</em> allocate an array.</li>
</ul>
<p>In favor of 1:</p>
<ul>
<li>No way to get that performance manually</li>
<li>If you want 5, you can manually do it with 1.</li>
</ul>
<p>WH: We've tried to do call site memoization in the past. In ES3 we allowed behaviorally equivalent closures that didn't capture any free variables to share identity. We also made regexp literals share identity. Since then we've backed out of both of those decisions.</p>
<p>BE: ES3 left closure memoization up to implementations. ES5 forbade closure memoization.</p>
<p>MM: (revisiting const functions)</p>
<ul>
<li>const functions <a href="http://wiki.ecmascript.org/doku.php?id=strawman:const_functions">http://wiki.ecmascript.org/doku.php?id=strawman:const_functions</a> , by freezing the function, safely enable the joining optimization that ES3 unsafely tried to allow.</li>
</ul>
<p>MM: 1: the memoization is the raw string contents and the holes, only -- the information that goes into the callsite (nee template) object.</p>
<p>Discussion of performance via caching on &quot;call sites&quot;</p>
<p>MM: The consequences of 1 are easy to enumerate</p>
<p>WH: If we do 1, how would we implement that without leaking memory? An implementation would likely have a memoization map from strings to arrays. At what point can that map forget bindings? There is never a guarantee that a particular key string won't be used again.</p>
<p>(&quot;template identity&quot; is better to describe the thing that has been referred to as &quot;call site&quot;)</p>
<p>MM: For a given set of template contents, there exists no more than 1 template identity. That invariant is not violated by having 0. Within the implementation, one could have a weak-value map, mapping from the template contents to a weakly held template object. Weak value maps expose non-deterministic GC <a href="http://wiki.ecmascript.org/doku.php?id=strawman:weak_references#a_weakvaluemap">http://wiki.ecmascript.org/doku.php?id=strawman:weak_references#a_weakvaluemap</a> , but this internal use of a weak value map does not expose any effects of GC to JS code.</p>
<p>BE:</p>
<pre><code class="language-js"><span class="hljs-string">`hi, <span class="hljs-subst">${name}</span>`</span>
<span class="hljs-string">`hi, <span class="hljs-subst">${n}</span>`</span>
<span class="hljs-string">`hi, <span class="hljs-subst">${_}</span>`</span>
</code></pre>
<p>All of those would evaluate to the same template.</p>
<p>WH:</p>
<pre><code class="language-js"><span class="hljs-string">`hi, <span class="hljs-subst">${a}</span>, <span class="hljs-subst">${b}</span>`</span>
<span class="hljs-string">`hi, <span class="hljs-subst">${x}</span>, <span class="hljs-subst">${x}</span>`</span>
</code></pre>
<p>Would those two be the same template or two different templates?</p>
<p>BE: Same.</p>
<a href="#conclusionresolution-48-template-literal-call-site-object-caching"><h4 id="conclusionresolution-48-template-literal-call-site-object-caching">Conclusion/Resolution</h4></a><ul>
<li>The result would be 1</li>
</ul>
<a href="#what-is-the-this-binding-at-the-top-of-a-module"><h2 id="what-is-the-this-binding-at-the-top-of-a-module">What is the <code>this</code> binding at the top of a module?</h2></a><p>DH: Makes sense going forward to access the global via the Reflect library. <code>this</code> should be undefined at the top level of a module.</p>
<p>DD: I previously thought we had consensus on <code>Reflect.global</code>, but it's not in the spec</p>
<p>MM: The idea of something like <code>Reflect.global</code> is a good idea, but nervous about putting it ES6. Libraries like Caja need to be able to virtualize. Things we've made available through committee defined modules have been authority free, but global is authority bearing. Need more experience living with the ES6 module system before deciding how to make authority bearing things available for import.</p>
<p>DD: Won't indirect eval give you a script context global?</p>
<p>MM: Don't need to add something to ES6 for this issue.</p>
<p>DH: Agree</p>
<a href="#conclusionresolution-what-is-the-this-binding-at-the-top-of-a-module"><h4 id="conclusionresolution-what-is-the-this-binding-at-the-top-of-a-module">Conclusion/Resolution</h4></a><ul>
<li><code>this</code> is undefined</li>
</ul>
<a href="#49-arrayisarraynew-proxy-"><h2 id="49-arrayisarraynew-proxy-">4.9 Array.isArray(new Proxy([], {}))</h2></a><p>(TomVC, Brendan Eich, Rick Waldron, Allen Wirfs-Brock)</p>
<p>AWB: (Explains the expectation of <code>Array.isArray(...)</code>)</p>
<p>BE: Tom believes that <code>Array.isArray(new Proxy([], {})) === true</code></p>
<p>RW: (agrees)</p>
<p>AWB: Breaks the exotic array check</p>
<p>BE: But not the same</p>
<p>AWB: All the checks have been replaced with spec language re: exotic array object</p>
<p>MM: What are the observable differences of a proxied array</p>
<p>DH: (asserts that there are concrete cases for virtualization)</p>
<p>BE/MM: Allowing Array.isArray to behave this way is desirable</p>
<p>AWB: Unless the Proxy is poorly implemented</p>
<p>BE: We already decided that malicious or poorly implemented Proxy's don't restrict our</p>
<p>DH: Agree that <code>Array.isArray(new Proxy([], {})) === true</code></p>
<p>AWB: Even if they override all the mop operations, and no longer behaves like an Array</p>
<p>DH: Yes.</p>
<p>MM: Array is part of the primordials, don't have to specify how they come into existence, just how they behave once in existence.</p>
<p>BE:</p>
<pre><code>  <span class="hljs-keyword">Array</span>.isArray  | Result
----------------------------
    []       | <span class="hljs-literal">true</span>
<span class="hljs-keyword">new</span> <span class="hljs-type">Proxy</span>([], {})| <span class="hljs-literal">true</span>
<span class="hljs-keyword">Array</span> Subclass   | <span class="hljs-literal">true</span>
<span class="hljs-keyword">new</span> <span class="hljs-type">Nodelist</span>()   | <span class="hljs-literal">false</span>
<span class="hljs-keyword">new</span> <span class="hljs-type">Uint32Array</span>()| <span class="hljs-literal">false</span>
</code></pre>
<p>WH: (adds row to BE's table, based on the proposed isArray pseudocode on the slide that turns exotic objects that share Array's constructor into being themselves arrays)
Any exotic object that inherits from Array | ?!@#</p>
<p>DH: <code>let d = new Date; d.__proto__ = Array.prototype; Array.isArray(d)</code></p>
<p>DH: can allow typed objects where</p>
<p>BE: Any value object that inherits from Array, isArray =&gt; true</p>
<p>AWB: If an exotic object and inherits from Array, isArray =&gt; true</p>
<p>EA: @@isConcatSpreadable addresses the failure of Nodelist being unable to inherit from Array</p>
<p>AWB: Proxy with array as target may not behave anything liek an array</p>
<p>DH: But that's not what brands are about, simply about the bit that says &quot;the brand&quot;</p>
<p>AWB: Promise.isPromise wouldn't work if <code>new Proxy(new Promise(), {})</code></p>
<p>DD: But <code>Array.isArray</code> is a special case.</p>
<ul>
<li><code>Array.isArray</code> checks to see if its argument is a Proxy and then drills through to the target?</li>
</ul>
<p>DH: Addressed the lack of <code>typeof ...</code></p>
<p>DH: Could say that isArray is true IFF argument is an exotic array...</p>
<p>AWB: No, would break many things.</p>
<p>MM: Agreement with Dave, that these things should agree with eachother.</p>
<p>DH: A new term that means &quot;is inductively like an exotic array object&quot;.</p>
<p>DH: The meaning of isArray, there is reflectively a bit that's set that differentiates the behaviour to use for all special cases. Any data structure in which Array.isArray is true, JSON.stringify should follow the array path.</p>
<p>eg.</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> a = [];
<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(a, {});

<span class="hljs-built_in">Array</span>.isArray(p) === <span class="hljs-literal">true</span>;

<span class="hljs-keyword">var</span> o = {
  <span class="hljs-attr">a</span>: p    
};

<span class="hljs-built_in">JSON</span>.stringify(o); === <span class="hljs-string">'"{"a":[]}"'</span>;
</code></pre>
<p>DH: Any Proxy whose target is an Array, is treated like an Array.</p>
<p>WH: What about objects that inherit from Array?</p>
<p>DH: Only objects that were created using Array's construction mechanism (from last meeting) would be arrays. Objects that merely monkey-patched the proto chain to inherit from Array would not be arrays.
AWB: post meeting note -- &quot;created using Array's construction mechanism&quot; is equivlant to says &quot;is an exotic array object&quot; because that mechanism is the only way to create exotic array objects..</p>
<p>DH: For proxies, remember whether the target object was an array when the proxy was created, and return the same answer. Revoked array proxies would still be arrays.</p>
<p>DH: No other objects would be arrays.</p>
<a href="#conclusionresolution-49-arrayisarraynew-proxy-"><h4 id="conclusionresolution-49-arrayisarraynew-proxy-">Conclusion/Resolution</h4></a><ul>
<li><code>Array.isArray</code> checks to see if its argument is a Proxy of an Array and returns true when it is</li>
<li>b/c of revocable proxy: at creation time, discover it's an Array</li>
<li>Any data structure in which Array.isArray is true, JSON.stringify should take the Array path.</li>
<li>The following:</li>
<li>Array.isArray</li>
<li>Array.prototype.concat</li>
<li>isConcatSpreadable</li>
<li>JSON.stringify
should replace the occurrence of &quot;is exotic array object with the isArray interal check.</li>
</ul>
<p>AWB: In post meeting discussions MM and AWB concluded that Array.isArray should throw when applied to a revoked proxy. This is more consistent with overall revoked proxy behavior and eliminates the need for additiounal mechanism for remembering the array-ness of revoked proxies.</p>
<a href="#410-regexp-subclassing-fixes"><h2 id="410-regexp-subclassing-fixes">4.10 RegExp subclassing fixes</h2></a><p>(Allen Wirfs-Brock)</p>
<p>AWB: When ES6 refactored functions that either take a string or a RegExp there was an issue where the state on the RegExp instance was not set correctly.</p>
<p>AWB: These functions created a clone of the RegExp. But how do we do that when there are subclasses involved.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(regExp);
<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(regExp, flags);  <span class="hljs-comment">// Throws!</span>
</code></pre>
<p>AWB: Seems like we should allow passing in flags in this case.</p>
<p>MM: Isn't there a property that gives you the source?</p>
<p>AWB: There is <code>source</code>.</p>
<p>WH: Is this a compatible change?</p>
<p>AWB: The match function does not use lastIndex and other state.</p>
<p>MM: Is the cloning too big of a hammer?</p>
<p>AWB: We are making a clone because we do not want to mutate the internal state.</p>
<p>AWB: What are the obvious reasons to subclass RegExp? Maybe one wants to add new flags? But RegExp has no way of getting the flags as whole.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">let</span> re = <span class="hljs-regexp">/abc/mi</span>;
re.??? === <span class="hljs-string">'mi'</span>
</code></pre>
<p>AWB: Suggests adding a <code>flags</code> getter, and extending the RegExp constructor so that it can take a RegExp <em>and</em> a flags string, instead of throwing as it does now.</p>
<p>DH: Why do we need this?</p>
<p>AWB: The double dispatch is needed allow subclassing of RegExp.</p>
<p>DH: Why the @@isRegExp symbol</p>
<p>AWB: It is needed due to the double dispatch in functions that take either a RegExp or a string. If we didn't have the symbol then we would blindly just do <code>toString</code>.</p>
<p>WH: We just ran across the same problem earlier today with arrays. Why solve it in two different ways in the standard?</p>
<p>MM: Why don't we use symbols for these double dispatch functions and then we don't need the extra symbol, <code>@@isRegExp</code></p>
<p>BE: Does anyone want RegExp.prototype.match? Together with String.prototype.match, it's too confusing as to what is matching what.</p>
<p>DH: Can we revert or defer it?</p>
<p>AWB: This has been in the spec for years.</p>
<p>DH: There is a subtle difference between match and exec. If we now add match to RegExp it is going to be even more confusing.</p>
<p>AWB: We can just</p>
<p>AWB/BE: There are only four of these: match, replace, search, split</p>
<p>BE: Lets add symbol names for them.</p>
<p>BE: <code>Symbol.match</code>, <code>Symbol.replace</code>, <code>Symbol.search</code>, <code>Symbol.split</code></p>
<p>WH: Do we need @@species any more?</p>
<p>AWB: We might still need it for the <code>new this.constructor</code>.</p>
<p>DD: We use <code>@@species</code> for Promises.</p>
<p>MM: If Arrays use @@species, TypedArrays use @@species, Promises use @@species, then RegExp should use it too.</p>
<a href="#conclusionresolution-410-regexp-subclassing-fixes"><h4 id="conclusionresolution-410-regexp-subclassing-fixes">Conclusion/Resolution</h4></a><ul>
<li>Add RegExp.prototype.flags getter</li>
<li>Per discussion with JHD/AWB/BE: RegExp#flags should return a string of flags, but sorted alphabetically, to match #toString - eg /a/gim.flags === /a/igm.flags === 'gim'</li>
<li>Erratum from JHD:
<ul>
<li>All implementations I tested (FF/Chr/Saf/IE/node) alphabetize the flags in RegExp#toString - the spec should make sure that's concrete for both #toString and #flags</li>
<li>When there are no flags, the spec should probably specify that RegExp#flags returns an empty string</li>
<li>question to be clarified: is <code>flags</code> an own property on a RegExp instance, like &quot;source&quot;? Or, is it a getter defined on RegExp.prototype?</li>
</ul></li>
<li>Make RegExp constructor not throw for (re: RegExp, flags: string).
<ul>
<li>Essentially, implicit conversion of re -&gt; re.source when &quot;flags&quot; is provided?</li>
</ul></li>
<li>Rename the double dispatch methods to use use symbol names instead of string names.</li>
<li>Get rid of @@isRegExp</li>
<li>Add @@species for consistency.</li>
</ul>
<a href="#413-add-async-as-futurereservedword"><h2 id="413-add-async-as-futurereservedword">4.13 Add async as FutureReservedWord</h2></a><p>(Rick Waldron)</p>
<p>RW: We've reserved <code>await</code>, but not <code>async</code>. Should <code>async</code> be added as well?</p>
<p>DD: async is contextual. It is only valid as <code>async [nonewlinehere] function</code>.</p>
<p>EA: But async arrow function might need it.</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> (...) =&gt; {}
       ^ look ahead to here!

<span class="hljs-keyword">async</span>(...)
</code></pre>
<p>EA: The existing cover grammar covers this almost completely already.</p>
<p>DH: The cover grammar is creeping me out</p>
<ul>
<li>Not likely to have async the module and async the contextual keyword in the same scope and if you do...</li>
</ul>
<p>FN: Not insurmountable, if async (the module) is re-written for ES6 modules, nothing saying that it can't be renamed.</p>
<p>DH: Too much of an adoption tax</p>
<p>Conflict with existing Identifier use is not worth creating a <em>reserved</em> <em>word</em>.</p>
<a href="#conclusionresolution-413-add-async-as-futurereservedword"><h4 id="conclusionresolution-413-add-async-as-futurereservedword">Conclusion/Resolution</h4></a><ul>
<li>Will not reserve <code>async</code> as FutureReserveWord</li>
</ul>
<a href="#411-performance-issue-objectdefineproperties-objectcreate-objectassign"><h2 id="411-performance-issue-objectdefineproperties-objectcreate-objectassign">4.11 Performance issue: <code>Object.defineProperties</code>, <code>Object.create</code>, <code>Object.assign</code>.</h2></a><p>(Brian Terlson, John David Dalton)</p>
<p>BT: The performance issue arises when no error occurs, despite being specified that the first error thrown is to be held onto until the end of the operation.</p>
<p>MM/AWB: Hard to accept that this is specification related.</p>
<p>MM: Implementation effort should be spent, not spec change and user pain.</p>
<p>BT: Don't care at all about the determinism of the shape of the object when an error occurs. No library code does this, so why does the spec?</p>
<p>MM: The original specification focused on atomicity of the operation, which had actual performance costs and we backed out of that. This was the next best semantics.</p>
<p>WH: If more than one error, which do you get? Is that deterministic?</p>
<p>BT/MM/AWB: Always the first.</p>
<p>WH: First property or first temporally?</p>
<p>MM: First temporally. And yes, this leads to the same kind of &quot;nondeterminism&quot; in the choice of errors to throw.</p>
<p>AWB: Hard to believe this is the perf bottleneck. It doesn't seem credible.</p>
<p>BT: It's not the bottleneck.</p>
<p>MM: The burden is not big</p>
<p>JHD: Burden in shims or transpilers?</p>
<p>MM: Need for polyfills?</p>
<p>JHD: Still know of runtimes that need es5-shim</p>
<p>DD: If Object.assign is slow, no one will use it</p>
<p>RW: It will be a complete failure.</p>
<p>BE: The complaint is?</p>
<p>BT: If no one cares about this behaviour, why are we requiring it?</p>
<p>MM: I care.</p>
<p>JHD: Have a ticket in es6-shim for this, haven't implemented it due to the cost of try/catch</p>
<p>BE: If authors aren't testing for this and no one is paying attention to this...</p>
<p>AWB: But we don't want to leave it implementation dependent.</p>
<p>DD: In ES5 it's completely deterministic: you just throw the first</p>
<p>DL: No.</p>
<p>MM: If you consider the object as a bag of properties and not a sequence of properties.</p>
<p>JHD: Not a determinism issue, completely deterministic in all cases. The first error is always thrown</p>
<p>AWB: All the properties that can be computed will be computed.</p>
<p>MM: No disagreement</p>
<p>Discussion about who owns the burden of these performance</p>
<p>RW: Why does Object.assign also behave this way?</p>
<p>BT: b/c we made O.pD and O.c do this, and for consistency</p>
<p>RW: But my original proposal said nothing of doing this. Developer expectation would be: this behaves like jQuery, YUI, Dojo, etc.</p>
<p>MM: Do not object to <code>Object.assign</code> being specified without the try/catch because the operation is just a put and when the target is a non-Proxy it may still have setters invoked on put.</p>
<p>BE: if we made a mistake in not specifying order for Object.defineProperties or Object.assign, that's on us -- not a reason to inflict held-first-exception workaround for our mistake on devs of engines and polyfills</p>
<a href="#conclusionresolution-411-performance-issue-objectdefineproperties-objectcreate-objectassign"><h4 id="conclusionresolution-411-performance-issue-objectdefineproperties-objectcreate-objectassign">Conclusion/Resolution</h4></a><p>Continue tomorrow.</p>

</body>